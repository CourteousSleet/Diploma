package HydroPowerPlant
  
  extends Icons.MainPicture;
  //within HydroPowerPlant;

  package Icons "Subfolder to store all images of the main simulation systems."
    package MainPicture "HydroPowerPlant Logo"
      annotation(
        Icon(graphics = {Ellipse(origin = {-62, 61}, fillPattern = FillPattern.Solid, extent = {{-8, 7}, {8, -7}}), Line(origin = {0, 54}, points = {{-62, 0}, {62, 0}, {62, 0}}), Ellipse(origin = {63, 61}, fillPattern = FillPattern.Solid, extent = {{-7, 7}, {7, -7}}), Line(origin = {1, 68}, points = {{-63, 0}, {63, 0}, {63, 0}}), Line(origin = {-70, 18}, points = {{0, 44}, {0, -44}, {0, -44}}), Line(origin = {70, 17}, points = {{0, 43}, {0, -43}, {0, -43}}), Ellipse(origin = {-62, -23}, fillPattern = FillPattern.Solid, extent = {{-8, -7}, {8, 7}}), Ellipse(origin = {63, -22}, fillPattern = FillPattern.Solid, extent = {{-7, 8}, {7, -8}}), Line(origin = {-54, 15}, points = {{0, -39}, {0, 39}, {0, 39}}), Line(origin = {56, 16}, points = {{0, -38}, {0, 38}, {0, 38}}), Ellipse(origin = {-12, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {12, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-46, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-26, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {26, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {46, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Line(origin = {-36, 28}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {0, 28}, points = {{-12, 0}, {12, 0}, {12, 0}}), Line(origin = {36, 28}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {-36, 20}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {0, 20}, points = {{-12, 0}, {12, 0}, {12, 0}}), Line(origin = {36, 20}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {-50, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-22, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-16, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {16, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-42, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-30, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-8, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {8, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {23.2071, 3.14645}, points = {{-1.20711, 20.8536}, {-1.20711, -21.1464}, {0.792893, -19.1464}}), Line(origin = {30, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {42, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {50, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Ellipse(origin = {-46, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-26, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-12, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {12, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {26, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {46, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Line(origin = {0.44, -40}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Line(origin = {-1.52875, -58.5938}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Line(origin = {-2.84125, -79.3751}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Rectangle(origin = {1, 61}, fillPattern = FillPattern.Solid, extent = {{-63, 7}, {63, -7}}), Rectangle(origin = {-62, 19}, fillPattern = FillPattern.Solid, extent = {{-8, 43}, {8, -43}}), Rectangle(origin = {63, 20}, fillPattern = FillPattern.Solid, extent = {{-7, 42}, {7, -42}}), Rectangle(origin = {-46, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {-36, 24}, fillPattern = FillPattern.Solid, extent = {{-10, 4}, {10, -4}}), Rectangle(origin = {-26, 3}, fillPattern = FillPattern.Solid, extent = {{-4, -21}, {4, 21}}), Rectangle(origin = {-12, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {12, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {-1, 24}, fillPattern = FillPattern.Solid, extent = {{-13, 4}, {13, -4}}), Rectangle(origin = {26, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {36, 24}, fillPattern = FillPattern.Solid, extent = {{-10, 4}, {10, -4}}), Rectangle(origin = {46, 3}, fillPattern = FillPattern.Solid, extent = {{4, 21}, {-4, -21}})}));
    end MainPicture;

  end Icons;

  package Connectors "This package stores all the connectors needed to connect different classes within a model."
  
    connector DynamicInput
    end DynamicInput;
  
    connector DynamicOutput
    end DynamicOutput;
  
    connector WaterInput
      input Modelica.SIunits.Pressure p "Contact pressure";
      input Modelica.SIunits.MassFlowRate m_dot "Mass flow rate through the contact";
    end WaterInput;
  
    connector WaterOutput
      output Modelica.SIunits.Pressure p "Contact pressure";
      output Modelica.SIunits.MassFlowRate m_dot "Mass flow rate through the contact";
    end WaterOutput;
  
    connector ElectricityInput
      //input Modelica.Electrical.Analog.Sources.ConstantCurrent in_current;
      //input ... in_res;
      //input ... in_amp;
      //input ... in_pow;
    end ElectricityInput;
  
    connector ElectricityOutput
      //output Modelica.Electrical.Analog.Sources.ConstantCurrent out_current;
      //output ... out_res;
      //output ... out_amp;
      //output ... out_pow;
    end ElectricityOutput;
  
  end Connectors;

  record Presets "Stores important common constants for presets within the package."
    parameter Modelica.SIunits.Acceleration g             = Modelica.Constants.g_n     "Gravity";
    parameter Modelica.SIunits.Density rho                = 997.0                      "Density";
    parameter Modelica.SIunits.DynamicViscosity mu        = 0.89e-3                    "Dynamic viscosity of water";
    parameter Modelica.SIunits.Height eps                 = 5e-2                       "Pipe roughness height";
    parameter Modelica.SIunits.Pressure p_a               = 1.013e5                    "Atmospheric pressure";
    parameter Modelica.SIunits.Compressibility beta       = 4.5e-10                    "Water compressibility";
    parameter Modelica.SIunits.Compressibility beta_total = 1 / rho / 1000 ^ 2         "Total compressibility";
    parameter Modelica.SIunits.VolumeFlowRate V_0         = 21.000                     "Initial flow rate through the system";

  end Presets;

  package WaterSources   model River
      parameter Modelica.SIunits.Height H_r = 50;
      //"Initial water level above intake"
      parameter Modelica.SIunits.Length L = 500;
      //"Length of the reservoir"
      parameter Modelica.SIunits.Length w = 100;
      //"Bed width of the reservoir"
      parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg alpha = 30;
      //"The angle of the reservoir walls (zero angle corresponds to vertical walls)"
      parameter Real f = 0.0008;
      //"Friction factor of the reservoir"
      parameter Modelica.SIunits.Temperature T_i = Const.T_i;
      //"Initial temperature of the water"
      Modelica.SIunits.Area A;
      //"Vertical cros section";
      Modelica.SIunits.Mass m;
      //"Water mass";
      Modelica.SIunits.MassFlowRate m_dot;
      //"Water mass flow rate";
      Modelica.SIunits.VolumeFlowRate V_o_dot "Outlet flow rate", V_i_dot "Inlet flow rate", V_dot "Vertical flow rate";
      Modelica.SIunits.Velocity v;
      //"Water velocity";
      Modelica.SIunits.Momentum M;
      //"Water momentum";
      Modelica.SIunits.Force F_f;
      //"Friction force";
      Modelica.SIunits.Height H;
      //"Water height";
      Modelica.SIunits.Pressure p_2;
      //"Outside pressure";
      OpenHPL.Interfaces.Contact n(p = p_2);
      //"Outflow from reservoir"
    equation
// Define vertiacal cross section of the reservoir
      A = H * (w + 2 * H * Modelica.Math.tan(Modelica.SIunits.Conversions.from_deg(alpha)));
// Define water mass
      m = Const.rho * A * L;
// Define volumetric water flow rate
      V_dot = V_i_dot - V_o_dot;
// Define mass water flow rate
      m_dot = Const.rho * V_dot;
// Define water velocity
      v = m_dot / Const.rho / A;
// Define momentrumn
      M = L * m_dot;
// Define friction term
      F_f = 1 / 8 * Const.rho * f * L * (w + 2 * H / Modelica.Math.cos(alpha)) * v * abs(v);
// define derivatives of momentum and mass
      der(M) = A * (Const.p_a - p_2) + Const.g * Const.rho * A * H - F_f + Const.rho / A * (V_i_dot ^ 2 - V_o_dot ^ 2);
      der(m) = m_dot;
// define output pressure
      p_2 = Const.p_a + Const.g * Const.rho * H;
// output flow conector
      n.m_dot = -Const.rho * V_o_dot;
// output temperature conector
      n.T = T_i;
    end River;

    model Reservoir
      outer Presets data                                                 "using standard class with constants";
      
      // set if water level in the reservoir is constant
      parameter Boolean control_level = false                            "If checked, the level connector controls the water level of the reservoir"
        annotation (
        Dialog(group="Setup", enable = not useInflow),
        choices(checkBox = true));
        
      parameter Boolean useInflow = false                                "If checked, the inflow connector is used"
      annotation (
        Dialog(group="Setup", enable = not control_level),
        choices(checkBox = true));
        
      parameter SI.Height H_0=50                                         "Initial water level above intake"
      annotation (
                  Dialog(group="Setup",   enable = not control_level));
        
      // geometrical parameters in case when the inflow to reservoir is used
      parameter SI.Length l = 500                                        "Length of the reservoir"
      annotation (
        Dialog(group="Geometry"));
      
      parameter Modelica.SIunits.Length w = 100                          "Bed width of the reservoir"
      annotation (
        Dialog(group = "Geometry"));
      
      parameter Modelica.SIunits.Angle alpha = 0                         "The angle of the reservoir walls (zero angle corresponds to vertical walls)"
      annotation (
        Dialog(group = "Geometry"));
      
      parameter Real f = 0.0008                                          "Friction factor of the reservoir"
      annotation (
        Dialog(group = "Geometry"));
      
      // conditions of use
      Modelica.SIunits.Area A                                            "Vertical cross section";
      Modelica.SIunits.Mass m                                            "Water mass";
      Modelica.SIunits.MassFlowRate mdot                                 "Water mass flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot_i                             "Inlet flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot_o                             "Outlet flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot                               "Flow rate through the reservoir";
      Modelica.SIunits.Velocity v                                        "Water velocity";
      Modelica.SIunits.Momentum M                                        "Water momentum";
      Modelica.SIunits.Force F_f                                         "Friction force";
      SI.Height h                                                        "Water level";
      Modelica.SIunits.Pressure p_o                                      "Outlet pressure";
    
      HydroPowerPlant.Connectors.WaterOutput w_o(p = p_o)                "Outflow from reservoir";
    
      Modelica.Blocks.Interfaces.RealInput inflow = Vdot_i if useInflow  "Conditional input inflow of the reservoir";
      
      Modelica.Blocks.Interfaces.RealInput level=h if control_level      "Conditional input water level of the reservoir";
    
    initial equation
       
       if not control_level then
        h = H_0;
       end if;
       
    equation
      
      A = h * (w + h * Modelica.Math.tan(alpha))                         "Vertical cross section of the reservoir";
      m = data.rho * A * l                                               "Water mass in reservoir";
      Vdot = Vdot_i - Vdot_o                                             "Volumetric water flow rate";
      mdot = data.rho * Vdot                                             "Water mass flow rate";
      v = mdot / data.rho / A                                            "Water velocity";
      M = l * mdot                                                       "Momentum based on the length";
      
      F_f = 1 / 8 * data.rho * f *l  * (w + 2 * h  / Modelica.Math.cos(alpha)) * v * abs(v)
                                                                         "Friction force due to movement along the reservoir length";
      
      if control_level then
        Vdot_i - Vdot_o = 0;
        p_o = data.p_a + data.g * data.rho * h;
      elseif useInflow then
        der(M) = A * (data.p_a - p_o) + data.g * data.rho * A * h - F_f + data.rho / A * (Vdot_i^2 - Vdot_o^2);
        der(m) = mdot;
      else
        Vdot_i = 0;
        p_o = data.p_a + data.g * data.rho * h;
        der(m) = mdot;
      end if;
    
       o.mdot = -data.rho * Vdot_o "Output flow connector";
        
    end Reservoir;
  end WaterSources;

  package Watercourse
  
    model Forebay
      //parameter Modelica.SIunits.Volume absolute_volume = 1;
      //Modelica.SIunits.Volume available_volume;
      //WaterInput current_income_water;
    equation
//watch for filling forebay
    end Forebay;
  
    model Tailrace
      //parameter Modelica.Fluid.Sources.Boundary_pT bounds = 1;???
      //parameter Modelica.Fluid.Pipes.DynamicPipe pipe = 1;??
      //WaterInput  from_river;
      //WaterOutput for_forebay;
    equation
  
    end Tailrace;
  
    model IntakeStructure
      // parameter Modelica.SIunits.Volume basin = 1;
      // parameter Modelica.SIunits.Volume raw_collector = 1;
      // parameter Modelica.SIunits.Time delta_for_purification = 1; darsi
      // parameter Modelica.SIunits.Volume tank = 1;
      // parameter Modelica.Fluid.Machines.PrescribedPump pump = 1;
      // parameter Modelica.Fluid.Vessels.OpenTank tank_for_pureficated_water = 1;
      // WaterInput from_river;
      // WaterOutput to_surge (or to purification station);
    equation
  
    end IntakeStructure;
  
    model Penstock "Model of the penstock with elastic walls and compressible water. Simple Staggered grid scheme"
      outer Presets data "Using standard data set";
      import Modelica.Constants.pi;
      
      // Penstock
      parameter Modelica.SIunits.Height H = 420              "Height over which water fall in the pipe, m"
      annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Length L = 600              "Length of the pipe, m"
      annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Diameter D_i = 3.3          "Diameter from the input side of the pipe"
      annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Diameter D_o = D_i          "Diameter from the output side of the pipe"
      annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = 20  "Initial flow rate in the pipe, m3/s"
      annotation (
        Dialog(group = "Initialization"));
      parameter Integer N = 20                               "Number of segments"
      annotation (
        Dialog(group = "Discretization"));
      
      Modelica.SIunits.Diameter dD = 0.5 * (D_i + D_o), D[N] = linspace(D_i + dD / 2, D_o - dD / 2, N), D_[N + 1] = linspace(D_i, D_o, N + 1);
      Modelica.SIunits.Area A[N] = D .^ 2 * pi / 4, A_[N + 1] = D_ .^ 2 * pi / 4, A_m[N - 2], A_m_end, A_m_first;
      Modelica.SIunits.Pressure p_i, p_o, p_[N - 1], dp = data.rho * data.g * H / N, p_m[N - 2];
      Modelica.SIunits.Length dx = L / N, Per_m[N - 2];
      Modelica.SIunits.MassFlowRate mdot_R, mdot_V, mdot[N - 2], m_exp[N];
      Real F_ap[N - 1], F_m[N - 2], F_exp[N], p_eps_m[N - 2], Ap_m[3, N - 2], F_m_end, F_m_first;
      Modelica.SIunits.Force F_g[N - 2], F_p[N - 2];
      Modelica.SIunits.Density rho_m[N - 2], rho_m_end, rho_m_first;
      Modelica.SIunits.Velocity v_exp[N];
      Modelica.SIunits.VolumeFlowRate V_p_out[N - 2], V_p_out_end;
      
      extends OpenHPL.Interfaces.TwoContact;
    
    initial equation
      
      mdot_R = data.rho * Vdot_0;
      mdot_V = data.rho * Vdot_0;
      mdot = data.rho * Vdot_0 * ones(N - 2);
      p_ = p_i + dp:dp:p_i + dp * (N - 1);
    
    equation
      // Pipe flow rate
      mdot_R = i.mdot;
      mdot_V = -o.mdot;
      // pipe pressure
      p_i = i.p;
      p_o = o.p;
      // momentum balance for the first and last segment
      F_m_first = data.rho * A[1] * (1 + data.beta_total * ((p_[1] + p_i) / 2 - data.p_a));
      rho_m_first = data.rho * (1 + data.beta * ((p_[1] + p_i) / 2 - data.p_a));
      A_m_first = F_m_first / rho_m_first;
      dx * der(mdot_R) = A_m_first * (p_i - p_[1]) + F_m_first * data.g * dx * H / L - Functions.DarcyFriction.Friction(v_exp[1], 2 * sqrt(A_m_first / pi), dx, rho_m_first, data.mu, data.p_eps);
      F_m_end = data.rho * A[N] * (1 + data.beta_total * ((p_[N - 1] + p_o) / 2 - data.p_a));
      rho_m_end = data.rho * (1 + data.beta * ((p_[N - 1] + p_o) / 2 - data.p_a));
      A_m_end = F_m_end / rho_m_end;
      dx * der(mdot_V) = (-A_m_end * (p_o - p_[N - 1])) + F_m_end * data.g * dx * H / L - Functions.DarcyFriction.Friction(v_exp[N], 2 * sqrt(A_m_end / pi), dx, rho_m_end, data.mu, data.p_eps);
      // mass flow rate vector with all segments
      m_exp[1] = mdot_R;
      m_exp[2:N - 1] = mdot[:];
      m_exp[N] = mdot_V;
      // mass balance for pressure
      dx * data.rho * A_[2:N] .* data.beta_total .* der(p_) = m_exp[1:N - 1] - m_exp[2:N];
      // define middle pressures, densities and areas
      F_ap = data.rho * A_[2:N] .* (ones(N - 1) + data.beta_total * (p_ - data.p_a * ones(N - 1)));
      F_m = (F_ap[1:N - 2] + F_ap[2:N - 1]) / 2;
      F_exp[1] = data.rho * A_[1] * (1 + data.beta_total * (p_i - data.p_a));
      //F_m_first;
      F_exp[2:N - 1] = F_m[:];
      F_exp[N] = data.rho * A_[N + 1] * (1 + data.beta_total * (p_o - data.p_a));
      //F_m_end;
      v_exp = m_exp ./ F_exp;
      p_m = (p_[1:N - 2] + p_[2:N - 1]) / 2;
      rho_m = data.rho * (ones(N - 2) + data.beta * (p_m - data.p_a * ones(N - 2)));
      A_m = F_m ./ rho_m;
      Per_m = sqrt(4 * pi * A_m);
      // gravity and pressure drop forces
      F_g = dx * data.g * H / L * F_exp[2:N - 1];
      F_p = A_m .* (p_[1:N - 2] - p_[2:N - 1]);
      // friction and other coefficients
      for i in 1:N - 2 loop
        p_eps_m[i] = -Functions.DarcyFriction.Friction(v_exp[i + 1], 2 * sqrt(A_m[i] / pi), dx, rho_m[i], data.mu, data.p_eps) / v_exp[i + 1];
        Ap_m[1, i] = -((m_exp[i] - m_exp[i + 2]) / 4 - p_eps_m[i]);
        Ap_m[2, i] = (m_exp[i] + m_exp[i + 1]) / 4;
        Ap_m[3, i] = -(m_exp[i + 1] + m_exp[i + 2]) / 4;
      end for;
      // momentum balance
      dx * der(mdot) = Ap_m[1, :] .* v_exp[2:N - 1] + Ap_m[2, :] .* v_exp[1:N - 2] + Ap_m[3, :] .* v_exp[3:N] + F_g + F_p;
      // volumetric flow rates for all cells
      V_p_out = mdot ./ rho_m;
      V_p_out_end = mdot_V / (data.rho * (1 + data.beta * (p_o - data.p_a)));
  
    end Penstock;
  
    model SurgeChamber
      // parameter Modelica.SIunits.Volume chamber_volume;
      // WaterInput from_intake_structure;
      // WaterOutput to_penstock;
    equation
  
    end SurgeChamber;
  
    model DraftTube
      // parameter Modelica.SIunits.Area dtube_cross-sectional_area;
      // WaterInput from_turbine;
      // WaterOutput to_drop_point;
    equation
  
    end DraftTube;
  
  end Watercourse;

  package ElectricalInstallations
  
    model HydraulicTurbines
      // parameter Modelica.Mechanics.Rotational.Interfaces.
      // WaterInput from_penstock;
      // WaterOutput to_draft_tube;
    equation
  
    end HydraulicTurbines;
  
    model Powerhouse
    equation
  
    end Powerhouse;
  
  end ElectricalInstallations;
  annotation(
    version="0.9.0",
    versionDate="17/04/2022",
    uses(Modelica(version = "3.2.3")),
    preferredView="info",
    Documentation(info="<html>
      <p>HydroPowerPlant is a software package available for using in the OpenModelica Connection Editor development environment and used to simulate various mechanical and electrical systems and assemblies of hydroelectric power plants.</p>
      <p>The original <a href=\"https://github.com/CourteousSleet/Diploma\">repository</a>.</p>
</html>"));
    
end HydroPowerPlant;
