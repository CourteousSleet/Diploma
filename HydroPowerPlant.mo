package HydroPowerPlant
  extends Icons.MainPicture;
  //within HydroPowerPlant;

  package Icons "Subfolder to store all images of the main simulation systems."
    extends Modelica.Icons.IconsPackage;

    package MainPicture "HydroPowerPlant Logo"
      annotation(
        Icon(graphics = {Ellipse(origin = {-62, 61}, fillPattern = FillPattern.Solid, extent = {{-8, 7}, {8, -7}}), Line(origin = {0, 54}, points = {{-62, 0}, {62, 0}, {62, 0}}), Ellipse(origin = {63, 61}, fillPattern = FillPattern.Solid, extent = {{-7, 7}, {7, -7}}), Line(origin = {1, 68}, points = {{-63, 0}, {63, 0}, {63, 0}}), Line(origin = {-70, 18}, points = {{0, 44}, {0, -44}, {0, -44}}), Line(origin = {70, 17}, points = {{0, 43}, {0, -43}, {0, -43}}), Ellipse(origin = {-62, -23}, fillPattern = FillPattern.Solid, extent = {{-8, -7}, {8, 7}}), Ellipse(origin = {63, -22}, fillPattern = FillPattern.Solid, extent = {{-7, 8}, {7, -8}}), Line(origin = {-54, 15}, points = {{0, -39}, {0, 39}, {0, 39}}), Line(origin = {56, 16}, points = {{0, -38}, {0, 38}, {0, 38}}), Ellipse(origin = {-12, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {12, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-46, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-26, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {26, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {46, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Line(origin = {-36, 28}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {0, 28}, points = {{-12, 0}, {12, 0}, {12, 0}}), Line(origin = {36, 28}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {-36, 20}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {0, 20}, points = {{-12, 0}, {12, 0}, {12, 0}}), Line(origin = {36, 20}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {-50, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-22, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-16, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {16, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-42, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-30, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-8, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {8, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {23.2071, 3.14645}, points = {{-1.20711, 20.8536}, {-1.20711, -21.1464}, {0.792893, -19.1464}}), Line(origin = {30, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {42, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {50, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Ellipse(origin = {-46, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-26, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-12, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {12, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {26, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {46, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Line(origin = {0.44, -40}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Line(origin = {-1.52875, -58.5938}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Line(origin = {-2.84125, -79.3751}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Rectangle(origin = {1, 61}, fillPattern = FillPattern.Solid, extent = {{-63, 7}, {63, -7}}), Rectangle(origin = {-62, 19}, fillPattern = FillPattern.Solid, extent = {{-8, 43}, {8, -43}}), Rectangle(origin = {63, 20}, fillPattern = FillPattern.Solid, extent = {{-7, 42}, {7, -42}}), Rectangle(origin = {-46, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {-36, 24}, fillPattern = FillPattern.Solid, extent = {{-10, 4}, {10, -4}}), Rectangle(origin = {-26, 3}, fillPattern = FillPattern.Solid, extent = {{-4, -21}, {4, 21}}), Rectangle(origin = {-12, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {12, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {-1, 24}, fillPattern = FillPattern.Solid, extent = {{-13, 4}, {13, -4}}), Rectangle(origin = {26, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {36, 24}, fillPattern = FillPattern.Solid, extent = {{-10, 4}, {10, -4}}), Rectangle(origin = {46, 3}, fillPattern = FillPattern.Solid, extent = {{4, 21}, {-4, -21}})}));
    end MainPicture;
  end Icons;

  package Connectors "This package stores all the connectors needed to connect different classes within a model."
    extends Modelica.Icons.InterfacesPackage;

    package IWater
    
      connector WaterConnector
      
        Modelica.SIunits.Pressure p "Contact pressure";
        flow Modelica.SIunits.MassFlowRate mdot "Mass flow rate through the contact";
      
      end WaterConnector;
    
      connector WaterInput "Input connector"
        extends WaterConnector;
      end WaterInput;
      
      connector WaterOutput "Output connector"
        extends WaterConnector;
      end WaterOutput;

      partial model TwoPortWaterConnector "Model of two connectors"
      
        WaterInput i;
        
        WaterOutput o;
      
      end TwoPortWaterConnector;

      partial model MeticulousTwoPortWaterConnector
      
        Modelica.SIunits.MassFlowRate mdot "Mass flow rate";
        extends TwoPortWaterConnector;
      
      equation
        
        0 = i.mdot + o.mdot;
        mdot = i.mdot;
      
      end MeticulousTwoPortWaterConnector;

      partial model ExuberantTwoPortWaterConnector
      
        Modelica.SIunits.Pressure p "Pressure in a connection";
        Modelica.SIunits.MassFlowRate mdot "Mass flow rate";
        extends TwoPortWaterConnector;
      
      equation
      
        p = i.p;
        i.p = o.p;
        mdot = i.mdot + o.mdot;
      
      end ExuberantTwoPortWaterConnector;
    
    end IWater;

    package ITurbine 
partial model TurbineConnector
  
  extends IWater.MeticulousTwoPortWaterConnector;
  
  input Modelica.Blocks.Interfaces.RealInput u_t "Guide vane/nozzle opening of the turbine";
  
  Modelica.Blocks.Interfaces.RealOutput P_out(unit = "W") "Output mechanical power";

end TurbineConnector;

      partial model SmartTurbineConnector
      
        extends IWater.MeticulousTwoPortWaterConnector;
        
        parameter Boolean include_P_out = false "If checked, get a connector for the output power"
        annotation (choices(checkBox = true), Dialog(group="Outputs"));
        
        input Modelica.Blocks.Interfaces.RealInput u_t "[Guide vane|nozzle] opening of the turbine";
        
        Modelica.Blocks.Interfaces.RealOutput P_out(unit="W") if include_P_out "Mechanical Output power";
        
      end SmartTurbineConnector;
        
    end ITurbine;
  end Connectors;

  package Utilities
    extends Modelica.Icons.UtilitiesPackage;

    package Darcy_Weisbach
      extends Modelica.Icons.FunctionsPackage;

      function DarcyFrictionFactor "Friction force with Darcy friction factor"
      
        extends Modelica.Icons.Function;
        import Modelica.Constants.pi;
        
        input Modelica.SIunits.Velocity v           "Flow velocity";
        input Modelica.SIunits.Diameter D           "Pipe diameter";
        input Modelica.SIunits.Length L             "Pipe length";
        input Modelica.SIunits.Density rho          "Density";
        input Modelica.SIunits.DynamicViscosity mu  "Dynamic viscosity of water";
        input Modelica.SIunits.Height p_eps         "Pipe roughness height";
        
        output Modelica.SIunits.Force F_f           "Friction force";
        
        protected
          Modelica.SIunits.ReynoldsNumber N_Re      "Reynolds number";
          Real f                                    "Friction factor";
      
      algorithm
        
        N_Re := rho * abs(v) * D / mu;
        f := CalculateByReynoldsNumber(N_Re, D, p_eps);
        F_f := 0.5 * pi * f * rho * L * v * abs(v) * D / 4;

      end DarcyFrictionFactor;

      function CalculateByReynoldsNumber
      
        extends Modelica.Icons.Function;
        
        input Modelica.SIunits.ReynoldsNumber N_Re "Reynolds number";
        input Modelica.SIunits.Diameter D "Pipe diameter";
        input Modelica.SIunits.Height p_eps "Pipe roughness height";
        
        output Real fD "Darcy friction factor";
        
        protected
          Real arg;
        
          // Algorithm for computing specific enthalpy
          Modelica.SIunits.ReynoldsNumber N_Re_lam = 2100, N_Re_tur = 2300;
          Real X[4, 4], Y[4], K[4];
      
      algorithm
        
        X := [N_Re_lam ^ 3, N_Re_lam ^ 2, N_Re_lam, 1; N_Re_tur ^ 3, N_Re_tur ^ 2, N_Re_tur, 1; 3 * N_Re_lam ^ 2, 2 * N_Re_lam, 1, 0; 3 * N_Re_tur ^ 2, 2 * N_Re_tur, 1, 0];
        
        Y := {64 / N_Re_lam, 1 / (2 * log10(p_eps / 3.7 / D + 5.74 / N_Re_tur ^ 0.9)) ^ 2, -64 / N_Re_lam ^ 2, -0.25 * 0.316 / N_Re_tur ^ 1.25};
        
        K := Modelica.Math.Matrices.inv(X) * Y;
        
        arg := p_eps / 3.7 / D + 5.74 / (N_Re + Modelica.Constants.eps) ^ 0.9;
        
        if N_Re <= 0 then
          fD := 0;
        elseif N_Re <= 2100 then
          fD := 64 / N_Re;
        elseif N_Re < 2300 then
          fD := K[1] * N_Re ^ 3 + K[2] * N_Re ^ 2 + K[3] * N_Re + K[4];
        else
          fD := 1 / (2 * log10(arg)) ^ 2;
        end if;

      end CalculateByReynoldsNumber;
    
    end Darcy_Weisbach;
  
  end Utilities;

  record Presets "Stores important common constants for presets within the package."
  
    extends Modelica.Icons.Record;
    
    parameter Modelica.SIunits.Acceleration g = Modelica.Constants.g_n "Gravity";
    parameter Modelica.SIunits.Density rho = 997.0 "Density";
    parameter Modelica.SIunits.DynamicViscosity mu = 0.89e-3 "Dynamic viscosity of water";
    parameter Modelica.SIunits.Height eps = 5e-2 "Pipe roughness height";
    parameter Modelica.SIunits.Pressure p_a = 1.013e5 "Atmospheric pressure";
    parameter Modelica.SIunits.Compressibility beta = 4.5e-10 "Water compressibility";
    parameter Modelica.SIunits.Compressibility beta_total = 1 / rho / 1000 ^ 2 "Total compressibility";
    parameter Modelica.SIunits.VolumeFlowRate V_0 = 21.000 "Initial flow rate through the system";
    parameter Modelica.SIunits.Frequency f_0 = 50 "Initial frequency for TorqueGenerator";
    parameter Modelica.SIunits.MolarMass M_a = 28.97e-3 "Molar mass of air at standard temperature and pressure";
    parameter Boolean Steady = false "If checked, simulation starts from Steady State"
      annotation (choices(checkBox = true), Dialog(group = "Initialization"));
    parameter Modelica.SIunits.Height p_eps = 5e-2 "Pipe roughness height";
    
  end Presets;

  package WaterSources
    model River
      parameter Modelica.SIunits.Height H_r = 50;
      //"Initial water level above intake"
      parameter Modelica.SIunits.Length L = 500;
      //"Length of the reservoir"
      parameter Modelica.SIunits.Length w = 100;
      //"Bed width of the reservoir"
      parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg alpha = 30;
      //"The angle of the reservoir walls (zero angle corresponds to vertical walls)"
      parameter Real f = 0.0008;
      //"Friction factor of the reservoir"
      parameter Modelica.SIunits.Temperature T_i = Const.T_i;
      //"Initial temperature of the water"
      Modelica.SIunits.Area A;
      //"Vertical cros section";
      Modelica.SIunits.Mass m;
      //"Water mass";
      Modelica.SIunits.MassFlowRate m_dot;
      //"Water mass flow rate";
      Modelica.SIunits.VolumeFlowRate V_o_dot "Outlet flow rate", V_i_dot "Inlet flow rate", V_dot "Vertical flow rate";
      Modelica.SIunits.Velocity v;
      //"Water velocity";
      Modelica.SIunits.Momentum M;
      //"Water momentum";
      Modelica.SIunits.Force F_f;
      //"Friction force";
      Modelica.SIunits.Height H;
      //"Water height";
      Modelica.SIunits.Pressure p_2;
      //"Outside pressure";
      Connectors.IWater.WaterConnector n(p = p_2);
      //"Outflow from reservoir"
    equation
// Define vertiacal cross section of the reservoir
      A = H * (w + 2 * H * Modelica.Math.tan(Modelica.SIunits.Conversions.from_deg(alpha)));
// Define water mass
      m = Const.rho * A * L;
// Define volumetric water flow rate
      V_dot = V_i_dot - V_o_dot;
// Define mass water flow rate
      m_dot = Const.rho * V_dot;
// Define water velocity
      v = m_dot / Const.rho / A;
// Define momentrumn
      M = L * m_dot;
// Define friction term
      F_f = 1 / 8 * Const.rho * f * L * (w + 2 * H / Modelica.Math.cos(alpha)) * v * abs(v);
// define derivatives of momentum and mass
      der(M) = A * (Const.p_a - p_2) + Const.g * Const.rho * A * H - F_f + Const.rho / A * (V_i_dot ^ 2 - V_o_dot ^ 2);
      der(m) = m_dot;
// define output pressure
      p_2 = Const.p_a + Const.g * Const.rho * H;
// output flow conector
      n.m_dot = -Const.rho * V_o_dot;
// output temperature conector
      n.T = T_i;
    end River;

    model Reservoir
    
      outer Presets data;
      
      // set if water level in the reservoir is constant
      parameter Boolean control_level = false     "If checked, the level connector controls the water level of the reservoir";
      parameter Boolean useInflow = false         "If checked, the inflow connector is used";
      parameter Modelica.SIunits.Height H_0 = 50  "Initial water level above intake";
     
      // geometrical parameters in case when the inflow to reservoir is used
      parameter Modelica.SIunits.Length l = 500   "Length of the reservoir";
      parameter Modelica.SIunits.Length w = 100   "Bed width of the reservoir";
      parameter Modelica.SIunits.Angle alpha = 0  "The angle of the reservoir walls (zero angle corresponds to vertical walls)";
      parameter Real f = 0.0008                   "Friction factor of the reservoir";
      
      Modelica.SIunits.Area A                     "Vertical cross section";
      Modelica.SIunits.Mass m                     "Water mass";
      Modelica.SIunits.MassFlowRate mdot          "Water mass flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot_i      "Inlet flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot_o      "Outlet flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot        "Flow rate through the reservoir";
      Modelica.SIunits.Velocity v                 "Water velocity";
      Modelica.SIunits.Momentum M                 "Water momentum";
      Modelica.SIunits.Force F_f                  "Friction force";
      Modelica.SIunits.Height h                   "Water level";
      Modelica.SIunits.Pressure p_o               "Outlet pressure";
      
      HydroPowerPlant.Connectors.IWater.WaterConnector w_o(p = p_o)       "Outflow from reservoir";
      Modelica.Blocks.Interfaces.RealInput inflow = Vdot_i if useInflow   "Conditional input inflow of the reservoir";
      Modelica.Blocks.Interfaces.RealInput level = h if control_level     "Conditional input water level of the reservoir";
    
    initial equation
      
      if not control_level then
        h = H_0;
      end if;
    
    equation
      
      A = h * (w + h * Modelica.Math.tan(alpha))        "Vertical cross section of the reservoir";
      m = data.rho * A * l                              "Water mass in reservoir";
      Vdot = Vdot_i - Vdot_o                            "Volumetric water flow rate";
      mdot = data.rho * Vdot                            "Water mass flow rate";
      v = mdot / data.rho / A                           "Water velocity";
      M = l * mdot                                      "Momentum based on the length";
      F_f = 1 / 8 * data.rho * f * l * (w + 2 * h / Modelica.Math.cos(alpha)) * v * abs(v) "Friction force due to movement along the reservoir length";
      
      if control_level then
      
        Vdot_i - Vdot_o = 0;
        p_o = data.p_a + data.g * data.rho * h;
      
      elseif useInflow then
      
        der(M) = A * (data.p_a - p_o) + data.g * data.rho * A * h - F_f + data.rho / A * (Vdot_i ^ 2 - Vdot_o ^ 2);
        der(m) = mdot;
      
      else
        
        Vdot_i = 0;
        p_o = data.p_a + data.g * data.rho * h;
        der(m) = mdot;
      
      end if;
      
      w_o.mdot = -data.rho * Vdot_o                        "Output flow connector";
    
    end Reservoir;
  end WaterSources;

  package Watercourse
    model Penstock "Model of the penstock with elastic walls and compressible water. Simple Staggered grid scheme"
      outer Presets data "Using standard data set";
      import Modelica.Constants.pi;
      // Penstock
      parameter Modelica.SIunits.Height H = 420 "Height over which water fall in the pipe, m" annotation(
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Length L = 600 "Length of the pipe, m" annotation(
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Diameter D_i = 3.3 "Diameter from the input side of the pipe" annotation(
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Diameter D_o = D_i "Diameter from the output side of the pipe" annotation(
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = 20 "Initial flow rate in the pipe, m3/s" annotation(
        Dialog(group = "Initialization"));
      parameter Integer N = 20 "Number of segments" annotation(
        Dialog(group = "Discretization"));
      Modelica.SIunits.Diameter dD = 0.5 * (D_i + D_o), D[N] = linspace(D_i + dD / 2, D_o - dD / 2, N), D_[N + 1] = linspace(D_i, D_o, N + 1);
      Modelica.SIunits.Area A[N] = D .^ 2 * pi / 4, A_[N + 1] = D_ .^ 2 * pi / 4, A_m[N - 2], A_m_end, A_m_first;
      Modelica.SIunits.Pressure p_i, p_o, p_[N - 1], dp = data.rho * data.g * H / N, p_m[N - 2];
      Modelica.SIunits.Length dx = L / N, Per_m[N - 2];
      Modelica.SIunits.MassFlowRate mdot_R, mdot_V, mdot[N - 2], m_exp[N];
      Real F_ap[N - 1], F_m[N - 2], F_exp[N], p_eps_m[N - 2], Ap_m[3, N - 2], F_m_end, F_m_first;
      Modelica.SIunits.Force F_g[N - 2], F_p[N - 2];
      Modelica.SIunits.Density rho_m[N - 2], rho_m_end, rho_m_first;
      Modelica.SIunits.Velocity v_exp[N];
      Modelica.SIunits.VolumeFlowRate V_p_out[N - 2], V_p_out_end;
    initial equation
      mdot_R = data.rho * Vdot_0;
      mdot_V = data.rho * Vdot_0;
      mdot = data.rho * Vdot_0 * ones(N - 2);
      p_ = p_i + dp:dp:p_i + dp * (N - 1);
    equation
// Pipe flow rate
      mdot_R = i.mdot;
      mdot_V = -o.mdot;
// Pipe pressure
      p_i = i.p;
      p_o = o.p;
// Momentum balance for the first and last segment
      F_m_first = data.rho * A[1] * (1 + data.beta_total * ((p_[1] + p_i) / 2 - data.p_a));
      rho_m_first = data.rho * (1 + data.beta * ((p_[1] + p_i) / 2 - data.p_a));
      A_m_first = F_m_first / rho_m_first;
      dx * der(mdot_R) = A_m_first * (p_i - p_[1]) + F_m_first * data.g * dx * H / L - Functions.DarcyFriction.Friction(v_exp[1], 2 * sqrt(A_m_first / pi), dx, rho_m_first, data.mu, data.p_eps);
      F_m_end = data.rho * A[N] * (1 + data.beta_total * ((p_[N - 1] + p_o) / 2 - data.p_a));
      rho_m_end = data.rho * (1 + data.beta * ((p_[N - 1] + p_o) / 2 - data.p_a));
      A_m_end = F_m_end / rho_m_end;
      dx * der(mdot_V) = (-A_m_end * (p_o - p_[N - 1])) + F_m_end * data.g * dx * H / L - Functions.DarcyFriction.Friction(v_exp[N], 2 * sqrt(A_m_end / pi), dx, rho_m_end, data.mu, data.p_eps);
// Mass flow rate vector with all segments
      m_exp[1] = mdot_R;
      m_exp[2:N - 1] = mdot[:];
      m_exp[N] = mdot_V;
// Mass balance for pressure
      dx * data.rho * A_[2:N] .* data.beta_total .* der(p_) = m_exp[1:N - 1] - m_exp[2:N];
// Define middle pressures, densities and areas
      F_ap = data.rho * A_[2:N] .* (ones(N - 1) + data.beta_total * (p_ - data.p_a * ones(N - 1)));
      F_m = (F_ap[1:N - 2] + F_ap[2:N - 1]) / 2;
      F_exp[1] = data.rho * A_[1] * (1 + data.beta_total * (p_i - data.p_a));
// F_m_first;
      F_exp[2:N - 1] = F_m[:];
      F_exp[N] = data.rho * A_[N + 1] * (1 + data.beta_total * (p_o - data.p_a));
// F_m_end;
      v_exp = m_exp ./ F_exp;
      p_m = (p_[1:N - 2] + p_[2:N - 1]) / 2;
      rho_m = data.rho * (ones(N - 2) + data.beta * (p_m - data.p_a * ones(N - 2)));
      A_m = F_m ./ rho_m;
      Per_m = sqrt(4 * pi * A_m);
// Gravity and pressure drop forces
      F_g = dx * data.g * H / L * F_exp[2:N - 1];
      F_p = A_m .* (p_[1:N - 2] - p_[2:N - 1]);
// Friction and other coefficients
      for i in 1:N - 2 loop
        p_eps_m[i] = -Functions.DarcyFriction.Friction(v_exp[i + 1], 2 * sqrt(A_m[i] / pi), dx, rho_m[i], data.mu, data.p_eps) / v_exp[i + 1];
        Ap_m[1, i] = -((m_exp[i] - m_exp[i + 2]) / 4 - p_eps_m[i]);
        Ap_m[2, i] = (m_exp[i] + m_exp[i + 1]) / 4;
        Ap_m[3, i] = -(m_exp[i + 1] + m_exp[i + 2]) / 4;
      end for;
// Momentum balance
      dx * der(mdot) = Ap_m[1, :] .* v_exp[2:N - 1] + Ap_m[2, :] .* v_exp[1:N - 2] + Ap_m[3, :] .* v_exp[3:N] + F_g + F_p;
// Volumetric flow rates for all cells
      V_p_out = mdot ./ rho_m;
      V_p_out_end = mdot_V / (data.rho * (1 + data.beta * (p_o - data.p_a)));
    end Penstock;

    model SurgeChamber "Model of the surge chamber/shaft"
    
      outer Presets data;
      import Modelica.Constants.pi;
      
      
      parameter Modelica.SIunits.Height H = 120                     "Vertical component of the length of the surge shaft";
      parameter Modelica.SIunits.Length L = 140                     "Length of the surge shaft";
      parameter Modelica.SIunits.Diameter D = 3.4                   "Diameter of the surge shaft";
      parameter Modelica.SIunits.Height p_eps = data.p_eps          "Pipe roughness height";
      parameter Modelica.SIunits.Diameter D_so = 1.7                "If Sharp orifice type: Diameter of sharp orifice";
      parameter Modelica.SIunits.Diameter D_t = 1.7                 "If Throttle value type: Diameter of throat";
      parameter Modelica.SIunits.Diameter L_t = 5                   "If Throttle value type: Diameter of throat";
      
      parameter Boolean SteadyState = data.Steady                   "If true - starts from Steady State";
      // steady state values for flow rate and water level in surge tank
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = 0          "Initial flow rate in the surge tank";
      parameter Modelica.SIunits.Height h_0 = 69.9                  "Initial water height in the surge tank";
      parameter Modelica.SIunits.Pressure p_ac = 4 * data.p_a       "Initial pressure of air-cushion inside the surge tank";
      parameter Modelica.SIunits.Temperature T_ac(displayUnit = "degC") = 298.15 "Initial air-cushion temperature";
      
      Modelica.SIunits.Mass m                                       "Water mass";
      Modelica.SIunits.Mass m_a = p_ac * A * (L - h_0 / cos_theta) * data.M_a / (Modelica.Constants.R * T_ac) "Air mass inside surge tank";
      Modelica.SIunits.Momentum M                                   "Water momuntum";
      Modelica.SIunits.Force Mdot                                   "Difference in influent and effulent momentum";
      Modelica.SIunits.Force F                                      "Total force acting in the surge tank";
      Modelica.SIunits.Area A = pi * D ^ 2 / 4                      "Cross sectional area of the surge tank";
      Modelica.SIunits.Area A_t = pi * D_t ^ 2 / 4                  "Cross sectional area of the throttle valve surge tank";
      Modelica.SIunits.Length l = h / cos_theta                     "Length of water in the surge tank";
      Real cos_theta = H / L                                        "Slope ratio";
      Modelica.SIunits.Velocity v                                   "Water velocity";
      Modelica.SIunits.Force F_p                                    "Pressure force";
      Modelica.SIunits.Force F_f                                    "Friction force";
      Modelica.SIunits.Force F_g                                    "Gravity force";
      Modelica.SIunits.Pressure p_t                                 "Pressure at top of the surge tank";
      Modelica.SIunits.Pressure p_b                                 "Pressure at bottom of the surge tank";
      Real phiSO                                                    "Dimensionless factor based on the type of fitting ";
      
      // initial values for differential variables
      Modelica.SIunits.Height h(start = h_0)                        "Water height in the surge tank";
      Modelica.SIunits.VolumeFlowRate Vdot(start = Vdot_0)          "Water flow rate";
    
      extends HydroPowerPlant.Connectors.IWater.ExuberantTwoPortWaterConnector;
    
    initial equation
      
      if SteadyState then
        der(M) = 0;
        der(m) = 0;
      else
        h = h_0;
      end if;
    
    equation
    
      der(m) = mdot     "Mass balance";
      der(M) = Mdot + F "Momentum balance";
  
      // Surge Chamber calculations
      v = Vdot / A;
      m = data.rho * A * l;
      M = m * v;
      p_t = data.p_a;
      F_f = Utilities.Darcy_Weisbach.DarcyFrictionFactor(v, D, l, data.rho, data.mu, p_eps) + A * phiSO * 0.5 * data.rho * abs(v) * v;
      phiSO = 0;
      F_p = (p_b - p_t) * A;
      
      mdot = data.rho * Vdot;
      Mdot = mdot * v;
      F = F_p - F_f - F_g;
      p_b = p "Linking bottom node pressure to connector";
      F_g = m * data.g * cos_theta;
    
    end SurgeChamber;

    model DraftTube "Model of a draft tube for reaction turbines"
      outer Presets data "Using standard data set";
      import Modelica.Constants.pi;
      // geometrical parameters of the draft tube
      parameter Modelica.SIunits.Length H = 7 "Vertical height of conical diffuser" annotation(
        Dialog(group = "Geometry", enable = DraftTubeType == OpenHPL.Types.DraftTube.ConicalDiffuser));
      parameter Modelica.SIunits.Length L = 7.017 "Slant height of conical diffuser, for conical diffuser L=H/cos(diffusion_angle/2), diffusion_anlge=8" annotation(
        Dialog(group = "Geometry", enable = DraftTubeType == OpenHPL.Types.DraftTube.ConicalDiffuser));
      parameter Modelica.SIunits.Diameter D_i = 4 "Diameter of the inlet side" annotation(
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Diameter D_o = 4.978 "Diameter of the outlet side, for conical diffuser D_o=D_i+2*H*tan(diffusion_angle/2)" annotation(
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Length L_m = 4 "Length of Main section of Moody spreading pipe" annotation(
        Dialog(group = "Geometry", enable = DraftTubeType == OpenHPL.Types.DraftTube.MoodySpreadingPipe));
      parameter Modelica.SIunits.Length L_b = 3 "Length of Branch section of Moody spreading pipe" annotation(
        Dialog(group = "Geometry", enable = DraftTubeType == OpenHPL.Types.DraftTube.MoodySpreadingPipe));
      parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg theta = 5 "Angle at which conical diffuser is inclined" annotation(
        Dialog(group = "Geometry", enable = DraftTubeType == OpenHPL.Types.DraftTube.ConicalDiffuser));
      parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg theta_moody = 30 "Angle at which Moody spreading pipes are branched possible value is 15,30,45,60 or 90)" annotation(
        Dialog(group = "Geometry", enable = DraftTubeType == OpenHPL.Types.DraftTube.MoodySpreadingPipe));
      parameter Modelica.SIunits.Height p_eps = data.p_eps "Pipe roughness height" annotation(
        Dialog(group = "Geometry"));
      // condition of steady state
      parameter Boolean SteadyState = data.Steady "if true - starts from Steady State" annotation(
        Dialog(group = "Initialization"));
      // staedy state value for flow rate
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = data.V_0 "Initial flow rate in the pipe" annotation(
        Dialog(group = "Initialization"));
      // possible parameters for temperature variation. Not finished...
      // parameter Boolean TempUse = data.TempUse "If checked - the water temperature is not constant" annotation (Dialog(group = "Initialization"));
      // parameter Modelica.SIunits.Temperature T_0 = data.T_0 "Initial water temperature in the pipe" annotation (Dialog(group = "Initialization", enable = TempUse));
      // variables
      Modelica.SIunits.Diameter D_ = 0.5 * (D_i + D_o) "Average diameter";
      Modelica.SIunits.Area A_i = D_i ^ 2 * pi / 4 "Inlet cross-section area of draft tube";
      Modelica.SIunits.Area A_o = D_o ^ 2 * pi / 4 "Outlet cross-section area of draft tube";
      Modelica.SIunits.Area A_ = D_ ^ 2 * pi / 4 "Average cross-section area of conical diffuser";
      Modelica.SIunits.Mass m "Mass of water inside conical diffuser";
      Modelica.SIunits.Mass m_m "Mass of water inside Main section Moody spreading pipes";
      Modelica.SIunits.Mass m_b "Mass of water inside Branch section Moody spreading pipes";
      Modelica.SIunits.MassFlowRate mdot_m "Mass flow rate inside Main section of Moody spreading pipes";
      Modelica.SIunits.MassFlowRate mdot_b "Mass flow rate inside Branch section of Moody spreading pipes";
      Modelica.SIunits.Volume V "Volume of water inside the draft tube";
      Modelica.SIunits.Momentum M "Momentum of water inside the draft tube";
      Modelica.SIunits.Force Mdot "Rate of change of water momentum";
      Modelica.SIunits.Force F "Total force acting in the tube";
      Modelica.SIunits.Force F_p "Pressure force";
      Modelica.SIunits.Force F_f "Fluid frictional force";
      Modelica.SIunits.Force F_g "Weight of water";
      Modelica.SIunits.Force F_fm "Fluid frictional force in the Main section of Moody spreading pipe";
      Modelica.SIunits.Force F_fb "Fluid frictional force in the Branch section of Moody spreading pipe";
      //Real cos_theta = H / L "slope ratio";
      Modelica.SIunits.Velocity v "Water velocity for conical diffuser";
      Modelica.SIunits.Velocity v_m "Water velocity inside Main section of Moody spreading pipes";
      Modelica.SIunits.Velocity v_b "Water velocity inside Branch section of Moody spreading pipes";
      Modelica.SIunits.Pressure p_i "Inlet pressure";
      Modelica.SIunits.Pressure p_o "Outlet pressure";
      //Modelica.SIunits.Pressure dp = p_o-p_i "Pressure drop in and out of draft tube";
      Real phi_d "Generalized friction factor for draft tube";
      Real phi_d_o "Initial generalized friction factor for Moody spreading pipes";
      Modelica.SIunits.VolumeFlowRate Vdot(start = Vdot_0, fixed = true) "Volumeteric flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot_b "Volumeteric flow rate for Branch section of Moody spreading pipes";
      Real cos_theta = Modelica.Math.cos(Modelica.SIunits.Conversions.from_deg(theta)) "Calculating cos_theta";
      Real cos_theta_moody = Modelica.Math.cos(Modelica.SIunits.Conversions.from_deg(theta_moody)) "Calculating cos_theta_moody";
      Real cos_theta_moody_by_2 = Modelica.Math.cos(Modelica.SIunits.Conversions.from_deg(theta_moody / 2)) "Calculating cos_theta_moody_by_2";
    initial equation
      if SteadyState then
        der(M) = 0;
//der(n.T) = 0;
      else
        Vdot = Vdot_0;
//n.T = p.T;
      end if;
    equation
      der(M) = Mdot + F "Momentum balance";
      if DraftTubeType == OpenHPL.Types.DraftTube.ConicalDiffuser then
        M = m * v;
        m = data.rho * V "Mass of water inside the draft tube";
        m_m = 0;
        m_b = 0;
// Unimportant for conical diffuser
        V = pi * H / 12 * (D_i ^ 2 + D_o ^ 2 + D_i * D_o) "Volume of water inside the draft tube";
        v = Vdot / A_;
        Vdot_b = 0;
// Unimportant for conical diffuser
        v_m = 0;
        v_b = 0;
// Unimportant for conical diffuser
        Mdot = mdot * v;
        mdot = data.rho * Vdot;
        mdot_m = 0;
        mdot_b = 0;
// Unimportant for conical diffuser
        F = F_p - F_g - F_f;
        F_p = p_i * A_i - p_o * A_o;
        F_f = Functions.DarcyFriction.Friction(v, D_, L, data.rho, data.mu, p_eps) + 1 / 2 * data.rho * v * abs(v) * A_i * phi_d;
        F_fm = 0;
        F_fb = 0;
        phi_d = 0.23 * (1 - D_i / D_o) ^ 2;
        phi_d_o = 0;
// Unimportant for conical diffuser
        F_g = m * data.g * cos_theta;
      elseif DraftTubeType == OpenHPL.Types.DraftTube.MoodySpreadingPipe then
// Taking momentum balance only on y-direction
        M = m_m * v_m + 2 * m_b * v_b * cos_theta_moody_by_2;
        m_m = data.rho * A_i * L_m;
        m_b = data.rho * A_o * L_m;
        m = m_m + 2 * m_b;
        v_m = Vdot / A_i;
        v_b = A_i / (2 * A_o) * v_m;
        v = v_m;
        V = A_i * L_m + 2 * A_o * L_b;
        Mdot = mdot_m * v_m + 2 * mdot_b * cos_theta_moody_by_2;
        mdot_m = data.rho * Vdot;
        mdot_b = data.rho * Vdot_b;
        Vdot_b = A_o * v_b;
        mdot = mdot_m;
        F = F_p - F_g - F_f;
        F_p = p_i * A_i - 2 * p_o * A_o * cos_theta_moody_by_2;
        F_g = m_m * data.g + 2 * m_b * data.g * cos_theta_moody_by_2;
        F_f = F_fm + 2 * F_fb * cos_theta_moody_by_2 + data.rho * v_m * abs(v_m) * A_i * phi_d;
        F_fm = Functions.DarcyFriction.Friction(v_m, D_i, L_m, data.rho, data.mu, p_eps);
        F_fb = Functions.DarcyFriction.Friction(v_b, D_o, L_b, data.rho, data.mu, p_eps);
// calculating phi_d
        phi_d = 1 + (v_b / v_m) ^ 2 - 2 * v_b / v_m * cos_theta_moody - phi_d_o * (v_b / v_m) ^ 2;
      end if;
// Connector
      p_i = i.p;
      p_o = o.p;
    end DraftTube;

    model Pipeline
      
      outer Presets data "Using standard data set";
      import Modelica.Constants.pi;
      
      // Geometrical parameters of the pipe
      parameter Modelica.SIunits.Length H = 25                    "Height difference from the inlet to the outlet";
      parameter Modelica.SIunits.Length L = 6600                  "Length of the pipe";
      parameter Modelica.SIunits.Diameter D_i = 5.8               "Diameter of the inlet side";
      parameter Modelica.SIunits.Diameter D_o = D_i               "Diameter of the outlet side";
      parameter Modelica.SIunits.Height p_eps = data.p_eps        "Pipe roughness height";
      
      // Condition of steady state
      parameter Boolean SteadyState = data.Steady                 "If true - starts from Steady State";
      
      // Steady state value for flow rate
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = data.V_0 "Initial flow rate in the pipe";
      
      // Variables
      Modelica.SIunits.Diameter D_ = 0.5 * (D_i + D_o)            "Average diameter";
      Modelica.SIunits.Mass m                                     "Water mass";
      Modelica.SIunits.Area A_i = D_i ^ 2 * pi / 4                "Inlet cross section area";
      Modelica.SIunits.Area A_o = D_o ^ 2 * pi / 4                "Outlet cross section area";
      Modelica.SIunits.Area A_ = D_ ^ 2 * pi / 4                  "Average cross section area";
      Real cos_theta = H / L                                      "Slope ratio";
      Modelica.SIunits.Velocity v                                 "Water velocity";
      Modelica.SIunits.Force F_f                                  "Friction force";
      Modelica.SIunits.Momentum M                                 "Water momentum";
      Modelica.SIunits.Pressure p_i                               "Inlet pressure";
      Modelica.SIunits.Pressure p_o                               "Outlet pressure";
      Modelica.SIunits.Pressure dp = p_o - p_i                    "Pressure difference across the pipe";
      Modelica.SIunits.VolumeFlowRate Vdot(start = Vdot_0)        "Flow rate";
    
      extends HydroPowerPlant.Connectors.IWater.MeticulousTwoPortWaterConnector;
    
    initial equation
    
      if SteadyState then
        der(M) = 0;
      end if;
    
    equation
      
      Vdot = mdot / data.rho;             // Water volumetric flow rate through the pipe

      v = Vdot / A_;                      // Water velocity

      M = data.rho * L * Vdot;            // Momentum and mass of water
      m = data.rho * A_ * L;

      F_f = Utilities.Darcy_Weisbach.DarcyFrictionFactor(v, D_, L, data.rho, data.mu, p_eps);                                 // Friction force
    
      der(M) = data.rho * Vdot ^ 2 * (1 / A_i - 1 / A_o) + p_i * A_i - p_o * A_o - F_f + m * data.g * cos_theta;  // Momentum balance

      p_i = i.p;                          // Pipe pressure
      p_o = o.p;
      
    end Pipeline;
  end Watercourse;

  package ElectricalInstallations
    package HydraulicTurbines
      extends Modelica.Icons.GearIcon;

      model GeneralTurbine "Simple turbine model with mechanical connectors"
      
        outer Presets data "Using standard class with global parameters";
        
        parameter Boolean ValveCapacity = true "If checked the guide vane capacity C_v should be specified, otherwise specify the nominal turbine parameters (net head and flow rate)";
        parameter Real C_v = 3.7 "Guide vane 'valve capacity'";
        parameter Modelica.SIunits.Height H_n = 460 "Nominal net head";
        parameter Modelica.SIunits.VolumeFlowRate Vdot_n = 23.4 "Nominal flow rate";
        parameter Modelica.SIunits.PerUnit u_n = 0.95 "Nominal guide vane opening";
        parameter Boolean ConstEfficiency = true "If checked the constant efficiency eta_h is used,
                  otherwise specify lookup table for efficiency";
        parameter Modelica.SIunits.Efficiency eta_h = 0.9 "Turbine hydraulic efficiency";
        parameter Real lookup_table[:, :] = [0, 0.4; 0.2, 0.7; 0.5, 0.9; 0.95, 0.95; 1.0, 0.93] "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency.";
        parameter Boolean WaterCompress = false "If checked the water is compressible in the penstock";
        
        extends PowerHouse.TorqueGenerator(power(y=Wdot_s));
        extends Connectors.ITurbine.SmartTurbineConnector;
        
        Modelica.SIunits.Pressure dp "Turbine pressure drop";
        Modelica.SIunits.EnergyFlowRate Kdot_i_tr "Kinetic energy flow";
        Modelica.SIunits.VolumeFlowRate Vdot "Flow rate";
        Real C_v_ "Guide vane 'valve capacity'";
        
        output Modelica.SIunits.EnergyFlowRate Wdot_s "Shaft power";
        Modelica.Blocks.Tables.CombiTable1D look_up_table(table = lookup_table);
        Modelica.Blocks.Math.Feedback lossCorrection;
      
      equation
      
        Vdot = if WaterCompress then mdot / (data.rho * (1 + data.beta * (i.p - data.p_a))) else mdot / data.rho "Checking for water compressibility";
      
        look_up_table.u[1] = u_t "Link the guide vane opening";
        
        C_v_ = if ValveCapacity then C_v else Vdot_n / sqrt(H_n * data.g * data.rho / data.p_a) / u_n "Define guide vane 'valve capacity' base on the Nominal turbine parameters";
        
        dp = Vdot ^ 2 * data.p_a / (C_v_ * u_t) ^ 2 "turbine valve equation for pressure drop";
        
        dp = i.p - o.p "Link the pressure drop to the ports";
        
        Kdot_i_tr = dp * Vdot "Turbine energy balance";
       
        if ConstEfficiency then
          Wdot_s = eta_h * Kdot_i_tr;
        else
          Wdot_s = look_up_table.y[1] * Kdot_i_tr;
        end if;
        
        connect(P_out, lossCorrection.y);
        connect(lossCorrection.u1, power.y);
        connect(frictionLoss.power, lossCorrection.u2);
        
      end GeneralTurbine;
    end HydraulicTurbines;

    package PowerHouse
      package Generators
        model CommonGenerator "Model of a simple generator with mechanical connectors"
        
          extends TorqueGenerator(final enable_nomSpeed = false, power(y = -Pload));
        
          Modelica.Blocks.Interfaces.RealInput Pload(unit = "W") "Electrical load power demand";

        end CommonGenerator;
      end Generators;

      partial model TorqueGenerator
      
        outer Presets data;
        import Modelica.Constants.pi;
      
        parameter Boolean useH= false "If checked, calculate the inertia from a given H value"
         annotation (Dialog(group = "Mechanical"), choices(checkBox=true));
        parameter Modelica.SIunits.Power Pmax = 100e6 "Maximum rated power (for torque limiting and H calculation)"
         annotation (Dialog(group = "Mechanical"));
        parameter Modelica.SIunits.Time H = 2.75 "Inertia constant H, typical 2s (high-head hydro) to 6s (gas or low-head hydro) production units"
          annotation (Dialog(group = "Mechanical", enable=useH));
        parameter Modelica.SIunits.MomentOfInertia J = 2e5 "Moment of inertia of the unit"
          annotation (Dialog(group = "Mechanical", enable=not useH));
        parameter Integer p(min=2) = 12 "Number of poles for mechanical speed calculation"
         annotation (Dialog(group = "Mechanical"),
                     choices( choice = 2 "2,[3000|3600] rpm",
                              choice = 4 "4,[1500|1800] rpm",
                              choice = 6 "6,[1000|1200] rpm",
                              choice = 8 "8,[750|900] rpm",
                              choice = 10 "10,[600|720] rpm",
                              choice = 12 "12,[500|600] rpm",
                              choice = 14 "14,[429|514] rpm",
                              choice = 16 "16,[375|450] rpm",
                              choice = 18 "18,[333|400] rpm",
                              choice = 20 "20,[300|360] rpm",
                              choice = 22 "22,[273|327] rpm",
                              choice = 24 "24,[250|300] rpm",
                              choice = 26 "26,[231|277] rpm",
                              choice = 28 "28,[214|257] rpm",
                              choice = 30 "30,[200|240] rpm",
                              choice = 28 "32,[187.5|225] rpm"));
          parameter Modelica.SIunits.Power Ploss = 0 "Friction losses of the unit at nominal speed"
          annotation (Dialog(group = "Mechanical"));
        parameter Modelica.SIunits.AngularVelocity w_0 = data.f_0 * 4 * pi / p "Initial mechanical angular velocity"
          annotation (Dialog(group = "Initialization"));
        parameter Boolean enable_w = false "If checked, get a connector for angular velocity output"
          annotation (choices(checkBox = true), Dialog(group = "Outputs"));
        parameter Boolean enable_f = false "If checked, get a connector for frequency output"
          annotation (choices(checkBox = true), Dialog(group = "Outputs"));
      
        Modelica.Blocks.Math.Division power2torque annotation (Placement(transformation(extent={{-66,-6},{-54,6}})));
        Modelica.Mechanics.Rotational.Sensors.SpeedSensor speedSensor annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=90,
              origin={20,-20})));
        Modelica.Mechanics.Rotational.Components.Inertia inertia(J=if useH then 2*H*Pmax/w_0^2 else J,  w(start=w_0)) annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        Modelica.Electrical.Machines.Losses.Friction friction(frictionParameters(PRef=Ploss, wRef=data.f_0*4*pi/p))
                                                              annotation (Placement(transformation(extent={{10,60},{30,40}})));
        Modelica.Mechanics.Rotational.Components.Fixed fixed annotation (Placement(transformation(extent={{30,50},{50,70}})));
        Modelica.Mechanics.Rotational.Sources.Torque torque annotation (Placement(transformation(extent={{-26,-6},{-14,6}})));
        Modelica.Blocks.Nonlinear.Limiter div0protect(uMax=Modelica.Constants.inf, uMin=Modelica.Constants.small) annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=180,
              origin={-40,-40})));
        Modelica.Blocks.Math.Gain toHz(k=Modelica.SIunits.Conversions.to_Hz(p/2)) annotation (Placement(transformation(extent={{76,-46},{88,-34}})));
        Modelica.Blocks.Nonlinear.Limiter torqueLimit(uMax=Pmax/w_0) annotation (Placement(transformation(
              extent={{6,6},{-6,-6}},
              rotation=180,
              origin={-40,0})));
        Modelica.Blocks.Interfaces.RealOutput f(unit="Hz") if enable_f "Output of generator frequency"
          annotation (Placement(transformation(extent={{100,-50},{120,-30}}),
                      iconTransformation(extent={{100,-50},{120,-30}})));
        Modelica.Blocks.Interfaces.RealOutput w if enable_w "Angular velocity of the generator"
          annotation (Placement(transformation(extent={{100,30},{120,50}},                                                                             rotation=0),
            iconTransformation(extent={{100,30},{120,50}})));
      
        Modelica.Mechanics.Rotational.Interfaces.Flange_b flange(phi(start=0, fixed=true))
                                                                 "Flange of right shaft" annotation (Placement(transformation(extent={{50,-10},{70,10}}),  iconTransformation(extent={{-10,-10},{10,10}})));
        Modelica.Blocks.Sources.RealExpression power annotation (Placement(transformation(extent={{-50,20},{-70,40}})));
        Modelica.Mechanics.Rotational.Sensors.PowerSensor frictionLoss annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=270,
              origin={20,20})));
        Modelica.Mechanics.Rotational.Sources.ConstantSpeed nomSpeed(w_fixed=w_0*p/2) annotation (Placement(transformation(extent={{86,-6},{74,6}})));
        Modelica.Mechanics.Rotational.Components.IdealGear toSysSpeed(ratio=2/p) "Converts to system speed based on p = 2" annotation (Placement(transformation(extent={{34,-6},{46,6}})));
        
      equation
        
        connect(toHz.u, speedSensor.w) annotation (Line(
            points={{74.8,-40},{20,-40},{20,-31}},
            color={0,0,127},
            pattern=LinePattern.Dash));
        
        connect(w, speedSensor.w) annotation (Line(
            points={{110,40},{50,40},{50,-40},{20,-40},{20,-31}},
            color={0,0,127},
            pattern=LinePattern.Dash));
        
        connect(div0protect.y, power2torque.u2) annotation (Line(points={{-46.6,-40},{-80,-40},{-80,-3.6},{-67.2,-3.6}},
                                                                                                                   color={0,0,127}));
        
        connect(f,toHz. y) annotation (Line(points={{110,-40},{88.6,-40}},
                                                                     color={0,0,127},
            pattern=LinePattern.Dash));
        
        connect(power2torque.y, torqueLimit.u) annotation (Line(points={{-53.4,0},{-54,0},{-54,8.88178e-16},{-47.2,8.88178e-16}},
                                                                                                                                color={0,0,127}));
        
        connect(torqueLimit.y, torque.tau) annotation (Line(points={{-33.4,-6.66134e-16},{-32,-6.66134e-16},{-32,0},{-27.2,0}},
                                                                                                                              color={0,0,127}));
        
        connect(speedSensor.w,div0protect. u) annotation (Line(points={{20,-31},{20,-40},{-32.8,-40}},
                                                                                               color={0,0,127}));
        
        connect(inertia.flange_b, speedSensor.flange) annotation (Line(points={{10,0},{20,0},{20,-10}}, color={0,0,0}));
        
        connect(friction.support, fixed.flange) annotation (Line(points={{20,60},{20,70},{40,70},{40,60}}, color={0,0,0}));
        
        connect(torque.flange, inertia.flange_a) annotation (Line(points={{-14,0},{-10,0}},
                                                                                         color={0,0,0}));
        
        connect(w, w) annotation (Line(points={{110,40},{105,40},{105,40},{110,40}}, color={0,0,127}));
        
        connect(power.y, power2torque.u1) annotation (Line(points={{-71,30},{-80,30},{-80,3.6},{-67.2,3.6}},
                                                                                                       color={0,0,127}));
        
        connect(frictionLoss.flange_a, inertia.flange_b) annotation (Line(points={{20,10},{20,0},{10,0}}, color={0,0,0}));
        
        connect(frictionLoss.flange_b, friction.flange) annotation (Line(points={{20,30},{20,40}}, color={0,0,0}));
        
        connect(nomSpeed.flange, flange) annotation (Line(points={{74,0},{60,0}}, color={0,0,0},
            pattern=LinePattern.Dash));
        
        connect(flange, toSysSpeed.flange_b) annotation (Line(points={{60,0},{46,0}}, color={0,0,0}));
        
        connect(toSysSpeed.flange_a, inertia.flange_b) annotation (Line(points={{34,0},{10,0}}, color={0,0,0}));
      
      end TorqueGenerator;
    end PowerHouse;
  end ElectricalInstallations;

  package WorkingModels
    extends Modelica.Icons.ExamplesPackage;

    model BasicExample "Basic model of a Hydropower plant."
    
      extends Modelica.Icons.Example;
      inner HydroPowerPlant.Presets data;
    
      HydroPowerPlant.WaterSources.Reservoir Reservoir(H_0 = 48);
      Modelica.Blocks.Sources.Ramp Control(duration = 1, height = -0.04615, offset = 0.7493, startTime = 600);
      HydroPowerPlant.Watercourse.Pipeline IntakeStructure(H = 23);
      HydroPowerPlant.Watercourse.Pipeline Discharge(H = 0.5, L = 600);
      HydroPowerPlant.WaterSources.Reservoir Tailrace(H_0 = 5);
      HydroPowerPlant.Watercourse.Pipeline Penstock(D_i = 3, D_o = 3, H = 428.5, L = 600);
      HydroPowerPlant.Watercourse.SurgeChamber SurgeChamber(h_0 = 69.9);
      HydroPowerPlant.ElectricalInstallations.HydraulicTurbines.GeneralTurbine Turbine(C_v = 3.7, ConstEfficiency = false);
    
    equation
    
      connect(Turbine.o, Discharge.i);
      connect(Control.y, Turbine.u_t);
      connect(Penstock.o, Turbine.i);
      connect(Reservoir.w_o, IntakeStructure.i);
      connect(IntakeStructure.o, SurgeChamber.i);
      connect(SurgeChamber.o, Penstock.i);
      connect(Discharge.o, Tailrace.w_o);
    
    end BasicExample;
  end WorkingModels;
  annotation(
    version = "0.9.0",
    versionDate = "17/04/2022",
    uses(Modelica(version = "3.2.3")),
    preferredView = "info",
    Documentation(info = "<html>
      <p>HydroPowerPlant is a software package available for using in the OpenModelica Connection Editor development environment and used to simulate various mechanical and electrical systems and assemblies of hydroelectric power plants.</p>
      <p>The original <a href=\"https://github.com/CourteousSleet/Diploma\">repository</a>.</p>
</html>"));
end HydroPowerPlant;
