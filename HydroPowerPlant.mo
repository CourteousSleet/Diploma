package HydroPowerPlant
  
  extends Icons.MainPicture;
  //within HydroPowerPlant;

  package Icons "Subfolder to store all images of the main simulation systems."
  
    extends Modelica.Icons.IconsPackage;
  
    package MainPicture "HydroPowerPlant Logo"
      annotation(
        Icon(graphics = {Ellipse(origin = {-62, 61}, fillPattern = FillPattern.Solid, extent = {{-8, 7}, {8, -7}}), Line(origin = {0, 54}, points = {{-62, 0}, {62, 0}, {62, 0}}), Ellipse(origin = {63, 61}, fillPattern = FillPattern.Solid, extent = {{-7, 7}, {7, -7}}), Line(origin = {1, 68}, points = {{-63, 0}, {63, 0}, {63, 0}}), Line(origin = {-70, 18}, points = {{0, 44}, {0, -44}, {0, -44}}), Line(origin = {70, 17}, points = {{0, 43}, {0, -43}, {0, -43}}), Ellipse(origin = {-62, -23}, fillPattern = FillPattern.Solid, extent = {{-8, -7}, {8, 7}}), Ellipse(origin = {63, -22}, fillPattern = FillPattern.Solid, extent = {{-7, 8}, {7, -8}}), Line(origin = {-54, 15}, points = {{0, -39}, {0, 39}, {0, 39}}), Line(origin = {56, 16}, points = {{0, -38}, {0, 38}, {0, 38}}), Ellipse(origin = {-12, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {12, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-46, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-26, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {26, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {46, 24}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Line(origin = {-36, 28}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {0, 28}, points = {{-12, 0}, {12, 0}, {12, 0}}), Line(origin = {36, 28}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {-36, 20}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {0, 20}, points = {{-12, 0}, {12, 0}, {12, 0}}), Line(origin = {36, 20}, points = {{-10, 0}, {10, 0}, {10, 0}}), Line(origin = {-50, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-22, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-16, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {16, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-42, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-30, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {-8, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {8, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {23.2071, 3.14645}, points = {{-1.20711, 20.8536}, {-1.20711, -21.1464}, {0.792893, -19.1464}}), Line(origin = {30, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {42, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Line(origin = {50, 3}, points = {{0, 21}, {0, -21}, {0, -21}}), Ellipse(origin = {-46, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-26, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {-12, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {12, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {26, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Ellipse(origin = {46, -18}, fillPattern = FillPattern.Solid, extent = {{-4, 4}, {4, -4}}), Line(origin = {0.44, -40}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Line(origin = {-1.52875, -58.5938}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Line(origin = {-2.84125, -79.3751}, points = {{-64, -4}, {-55, -20}, {-44, 0}, {-33, -20}, {-20, 0}, {-11, -20}, {1.5, 2}, {12.75, -20}, {24.375, 0}, {35.1875, -18}, {45.5938, -2}, {56.7969, -18}, {66, -6}}, thickness = 3, smooth = Smooth.Bezier), Rectangle(origin = {1, 61}, fillPattern = FillPattern.Solid, extent = {{-63, 7}, {63, -7}}), Rectangle(origin = {-62, 19}, fillPattern = FillPattern.Solid, extent = {{-8, 43}, {8, -43}}), Rectangle(origin = {63, 20}, fillPattern = FillPattern.Solid, extent = {{-7, 42}, {7, -42}}), Rectangle(origin = {-46, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {-36, 24}, fillPattern = FillPattern.Solid, extent = {{-10, 4}, {10, -4}}), Rectangle(origin = {-26, 3}, fillPattern = FillPattern.Solid, extent = {{-4, -21}, {4, 21}}), Rectangle(origin = {-12, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {12, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {-1, 24}, fillPattern = FillPattern.Solid, extent = {{-13, 4}, {13, -4}}), Rectangle(origin = {26, 3}, fillPattern = FillPattern.Solid, extent = {{-4, 21}, {4, -21}}), Rectangle(origin = {36, 24}, fillPattern = FillPattern.Solid, extent = {{-10, 4}, {10, -4}}), Rectangle(origin = {46, 3}, fillPattern = FillPattern.Solid, extent = {{4, 21}, {-4, -21}})}));
    end MainPicture;

  end Icons;

  package Connectors "This package stores all the connectors needed to connect different classes within a model."
  
    extends Modelica.Icons.InterfacesPackage;
  
    connector DynamicInput
    end DynamicInput;
  
    connector DynamicOutput
    end DynamicOutput;
  
    connector WaterInput
      input Modelica.SIunits.Pressure p "Contact pressure";
      input Modelica.SIunits.MassFlowRate m_dot "Mass flow rate through the contact";
    end WaterInput;
  
    connector WaterOutput
      output Modelica.SIunits.Pressure p "Contact pressure";
      output Modelica.SIunits.MassFlowRate m_dot "Mass flow rate through the contact";
    end WaterOutput;
  
    connector ElectricityInput
      //input Modelica.Electrical.Analog.Sources.ConstantCurrent in_current;
      //input ... in_res;
      //input ... in_amp;
      //input ... in_pow;
    end ElectricityInput;
  
    connector ElectricityOutput
      //output Modelica.Electrical.Analog.Sources.ConstantCurrent out_current;
      //output ... out_res;
      //output ... out_amp;
      //output ... out_pow;
    end ElectricityOutput;
  
  end Connectors;

  record Presets "Stores important common constants for presets within the package."
  
    extends Modelica.Icons.Record;
  
    parameter Modelica.SIunits.Acceleration g             = Modelica.Constants.g_n     "Gravity";
    parameter Modelica.SIunits.Density rho                = 997.0                      "Density";
    parameter Modelica.SIunits.DynamicViscosity mu        = 0.89e-3                    "Dynamic viscosity of water";
    parameter Modelica.SIunits.Height eps                 = 5e-2                       "Pipe roughness height";
    parameter Modelica.SIunits.Pressure p_a               = 1.013e5                    "Atmospheric pressure";
    parameter Modelica.SIunits.Compressibility beta       = 4.5e-10                    "Water compressibility";
    parameter Modelica.SIunits.Compressibility beta_total = 1 / rho / 1000 ^ 2         "Total compressibility";
    parameter Modelica.SIunits.VolumeFlowRate V_0         = 21.000                     "Initial flow rate through the system";

  end Presets;

  package WaterSources   model River
      parameter Modelica.SIunits.Height H_r = 50;
      //"Initial water level above intake"
      parameter Modelica.SIunits.Length L = 500;
      //"Length of the reservoir"
      parameter Modelica.SIunits.Length w = 100;
      //"Bed width of the reservoir"
      parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg alpha = 30;
      //"The angle of the reservoir walls (zero angle corresponds to vertical walls)"
      parameter Real f = 0.0008;
      //"Friction factor of the reservoir"
      parameter Modelica.SIunits.Temperature T_i = Const.T_i;
      //"Initial temperature of the water"
      Modelica.SIunits.Area A;
      //"Vertical cros section";
      Modelica.SIunits.Mass m;
      //"Water mass";
      Modelica.SIunits.MassFlowRate m_dot;
      //"Water mass flow rate";
      Modelica.SIunits.VolumeFlowRate V_o_dot "Outlet flow rate", V_i_dot "Inlet flow rate", V_dot "Vertical flow rate";
      Modelica.SIunits.Velocity v;
      //"Water velocity";
      Modelica.SIunits.Momentum M;
      //"Water momentum";
      Modelica.SIunits.Force F_f;
      //"Friction force";
      Modelica.SIunits.Height H;
      //"Water height";
      Modelica.SIunits.Pressure p_2;
      //"Outside pressure";
      OpenHPL.Interfaces.Contact n(p = p_2);
      //"Outflow from reservoir"
    equation
// Define vertiacal cross section of the reservoir
      A = H * (w + 2 * H * Modelica.Math.tan(Modelica.SIunits.Conversions.from_deg(alpha)));
// Define water mass
      m = Const.rho * A * L;
// Define volumetric water flow rate
      V_dot = V_i_dot - V_o_dot;
// Define mass water flow rate
      m_dot = Const.rho * V_dot;
// Define water velocity
      v = m_dot / Const.rho / A;
// Define momentrumn
      M = L * m_dot;
// Define friction term
      F_f = 1 / 8 * Const.rho * f * L * (w + 2 * H / Modelica.Math.cos(alpha)) * v * abs(v);
// define derivatives of momentum and mass
      der(M) = A * (Const.p_a - p_2) + Const.g * Const.rho * A * H - F_f + Const.rho / A * (V_i_dot ^ 2 - V_o_dot ^ 2);
      der(m) = m_dot;
// define output pressure
      p_2 = Const.p_a + Const.g * Const.rho * H;
// output flow conector
      n.m_dot = -Const.rho * V_o_dot;
// output temperature conector
      n.T = T_i;
    end River;

    model Reservoir
      outer Presets data                                                 "using standard class with constants";
      
      // set if water level in the reservoir is constant
      parameter Boolean control_level = false                            "If checked, the level connector controls the water level of the reservoir"
        annotation (
        Dialog(group="Setup", enable = not useInflow),
        choices(checkBox = true));
        
      parameter Boolean useInflow = false                                "If checked, the inflow connector is used"
      annotation (
        Dialog(group="Setup", enable = not control_level),
        choices(checkBox = true));
        
      parameter SI.Height H_0=50                                         "Initial water level above intake"
      annotation (
                  Dialog(group="Setup",   enable = not control_level));
        
      // geometrical parameters in case when the inflow to reservoir is used
      parameter SI.Length l = 500                                        "Length of the reservoir"
      annotation (
        Dialog(group="Geometry"));
      
      parameter Modelica.SIunits.Length w = 100                          "Bed width of the reservoir"
      annotation (
        Dialog(group = "Geometry"));
      
      parameter Modelica.SIunits.Angle alpha = 0                         "The angle of the reservoir walls (zero angle corresponds to vertical walls)"
      annotation (
        Dialog(group = "Geometry"));
      
      parameter Real f = 0.0008                                          "Friction factor of the reservoir"
      annotation (
        Dialog(group = "Geometry"));
      
      // conditions of use
      Modelica.SIunits.Area A                                            "Vertical cross section";
      Modelica.SIunits.Mass m                                            "Water mass";
      Modelica.SIunits.MassFlowRate mdot                                 "Water mass flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot_i                             "Inlet flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot_o                             "Outlet flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot                               "Flow rate through the reservoir";
      Modelica.SIunits.Velocity v                                        "Water velocity";
      Modelica.SIunits.Momentum M                                        "Water momentum";
      Modelica.SIunits.Force F_f                                         "Friction force";
      SI.Height h                                                        "Water level";
      Modelica.SIunits.Pressure p_o                                      "Outlet pressure";
    
      HydroPowerPlant.Connectors.WaterOutput w_o(p = p_o)                "Outflow from reservoir";
    
      Modelica.Blocks.Interfaces.RealInput inflow = Vdot_i if useInflow  "Conditional input inflow of the reservoir";
      
      Modelica.Blocks.Interfaces.RealInput level=h if control_level      "Conditional input water level of the reservoir";
    
    initial equation
       
       if not control_level then
        h = H_0;
       end if;
       
    equation
      
      A = h * (w + h * Modelica.Math.tan(alpha))                         "Vertical cross section of the reservoir";
      m = data.rho * A * l                                               "Water mass in reservoir";
      Vdot = Vdot_i - Vdot_o                                             "Volumetric water flow rate";
      mdot = data.rho * Vdot                                             "Water mass flow rate";
      v = mdot / data.rho / A                                            "Water velocity";
      M = l * mdot                                                       "Momentum based on the length";
      
      F_f = 1 / 8 * data.rho * f *l  * (w + 2 * h  / Modelica.Math.cos(alpha)) * v * abs(v)
                                                                         "Friction force due to movement along the reservoir length";
      
      if control_level then
        Vdot_i - Vdot_o = 0;
        p_o = data.p_a + data.g * data.rho * h;
      elseif useInflow then
        der(M) = A * (data.p_a - p_o) + data.g * data.rho * A * h - F_f + data.rho / A * (Vdot_i^2 - Vdot_o^2);
        der(m) = mdot;
      else
        Vdot_i = 0;
        p_o = data.p_a + data.g * data.rho * h;
        der(m) = mdot;
      end if;
    
       o.mdot = -data.rho * Vdot_o "Output flow connector";
        
    end Reservoir;
  end WaterSources;

  package Watercourse
  
    model Penstock "Model of the penstock with elastic walls and compressible water. Simple Staggered grid scheme"
      outer Presets data "Using standard data set";
      import Modelica.Constants.pi;
      
      // Penstock
      parameter Modelica.SIunits.Height H = 420              "Height over which water fall in the pipe, m"
      annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Length L = 600              "Length of the pipe, m"
      annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Diameter D_i = 3.3          "Diameter from the input side of the pipe"
      annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Diameter D_o = D_i          "Diameter from the output side of the pipe"
      annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = 20  "Initial flow rate in the pipe, m3/s"
      annotation (
        Dialog(group = "Initialization"));
      parameter Integer N = 20                               "Number of segments"
      annotation (
        Dialog(group = "Discretization"));
      
      Modelica.SIunits.Diameter dD = 0.5 * (D_i + D_o), D[N] = linspace(D_i + dD / 2, D_o - dD / 2, N), D_[N + 1] = linspace(D_i, D_o, N + 1);
      Modelica.SIunits.Area A[N] = D .^ 2 * pi / 4, A_[N + 1] = D_ .^ 2 * pi / 4, A_m[N - 2], A_m_end, A_m_first;
      Modelica.SIunits.Pressure p_i, p_o, p_[N - 1], dp = data.rho * data.g * H / N, p_m[N - 2];
      Modelica.SIunits.Length dx = L / N, Per_m[N - 2];
      Modelica.SIunits.MassFlowRate mdot_R, mdot_V, mdot[N - 2], m_exp[N];
      Real F_ap[N - 1], F_m[N - 2], F_exp[N], p_eps_m[N - 2], Ap_m[3, N - 2], F_m_end, F_m_first;
      Modelica.SIunits.Force F_g[N - 2], F_p[N - 2];
      Modelica.SIunits.Density rho_m[N - 2], rho_m_end, rho_m_first;
      Modelica.SIunits.Velocity v_exp[N];
      Modelica.SIunits.VolumeFlowRate V_p_out[N - 2], V_p_out_end;
      
      extends OpenHPL.Interfaces.TwoContact;
    
    initial equation
      
      mdot_R = data.rho * Vdot_0;
      mdot_V = data.rho * Vdot_0;
      mdot = data.rho * Vdot_0 * ones(N - 2);
      p_ = p_i + dp:dp:p_i + dp * (N - 1);
    
    equation
    
      // Pipe flow rate
      mdot_R = i.mdot;
      mdot_V = -o.mdot;
      
      // Pipe pressure
      p_i = i.p;
      p_o = o.p;
      
      // Momentum balance for the first and last segment
      F_m_first = data.rho * A[1] * (1 + data.beta_total * ((p_[1] + p_i) / 2 - data.p_a));
      rho_m_first = data.rho * (1 + data.beta * ((p_[1] + p_i) / 2 - data.p_a));
      A_m_first = F_m_first / rho_m_first;
      dx * der(mdot_R) = A_m_first * (p_i - p_[1]) + F_m_first * data.g * dx * H / L - Functions.DarcyFriction.Friction(v_exp[1], 2 * sqrt(A_m_first / pi), dx, rho_m_first, data.mu, data.p_eps);
      F_m_end = data.rho * A[N] * (1 + data.beta_total * ((p_[N - 1] + p_o) / 2 - data.p_a));
      rho_m_end = data.rho * (1 + data.beta * ((p_[N - 1] + p_o) / 2 - data.p_a));
      A_m_end = F_m_end / rho_m_end;
      dx * der(mdot_V) = (-A_m_end * (p_o - p_[N - 1])) + F_m_end * data.g * dx * H / L - Functions.DarcyFriction.Friction(v_exp[N], 2 * sqrt(A_m_end / pi), dx, rho_m_end, data.mu, data.p_eps);
      
      // Mass flow rate vector with all segments
      m_exp[1] = mdot_R;
      m_exp[2:N - 1] = mdot[:];
      m_exp[N] = mdot_V;
      
      // Mass balance for pressure
      dx * data.rho * A_[2:N] .* data.beta_total .* der(p_) = m_exp[1:N - 1] - m_exp[2:N];
      
      // Define middle pressures, densities and areas
      F_ap = data.rho * A_[2:N] .* (ones(N - 1) + data.beta_total * (p_ - data.p_a * ones(N - 1)));
      F_m = (F_ap[1:N - 2] + F_ap[2:N - 1]) / 2;
      F_exp[1] = data.rho * A_[1] * (1 + data.beta_total * (p_i - data.p_a));
      
      // F_m_first;
      F_exp[2:N - 1] = F_m[:];
      F_exp[N] = data.rho * A_[N + 1] * (1 + data.beta_total * (p_o - data.p_a));
      
      // F_m_end;
      v_exp = m_exp ./ F_exp;
      p_m = (p_[1:N - 2] + p_[2:N - 1]) / 2;
      rho_m = data.rho * (ones(N - 2) + data.beta * (p_m - data.p_a * ones(N - 2)));
      A_m = F_m ./ rho_m;
      Per_m = sqrt(4 * pi * A_m);
      
      // Gravity and pressure drop forces
      F_g = dx * data.g * H / L * F_exp[2:N - 1];
      F_p = A_m .* (p_[1:N - 2] - p_[2:N - 1]);
      
      // Friction and other coefficients
      for i in 1:N - 2 loop
        p_eps_m[i] = -Functions.DarcyFriction.Friction(v_exp[i + 1], 2 * sqrt(A_m[i] / pi), dx, rho_m[i], data.mu, data.p_eps) / v_exp[i + 1];
        Ap_m[1, i] = -((m_exp[i] - m_exp[i + 2]) / 4 - p_eps_m[i]);
        Ap_m[2, i] = (m_exp[i] + m_exp[i + 1]) / 4;
        Ap_m[3, i] = -(m_exp[i + 1] + m_exp[i + 2]) / 4;
      end for;
      
      // Momentum balance
      dx * der(mdot) = Ap_m[1, :] .* v_exp[2:N - 1] + Ap_m[2, :] .* v_exp[1:N - 2] + Ap_m[3, :] .* v_exp[3:N] + F_g + F_p;
      
      // Volumetric flow rates for all cells
      V_p_out = mdot ./ rho_m;
      V_p_out_end = mdot_V / (data.rho * (1 + data.beta * (p_o - data.p_a)));
  
    end Penstock;
  
    model SurgeChamber "Model of the surge chamber/shaft"
      outer Presets data "Using standard data set";
      import Modelica.Constants.pi;
    
      parameter Types.SurgeTank SurgeTankType = OpenHPL.Types.SurgeTank.STSimple "Types of surge tank";
      // Geometrical parameters of the surge tank
      parameter Modelica.SIunits.Height H = 120 "Vertical component of the length of the surge shaft";
      parameter Modelica.SIunits.Length L = 140 "Length of the surge shaft";
      parameter Modelica.SIunits.Diameter D = 3.4 "Diameter of the surge shaft";
      parameter Modelica.SIunits.Height p_eps = data.p_eps "Pipe roughness height";
      parameter Modelica.SIunits.Diameter D_so = 1.7 "If Sharp orifice type: Diameter of sharp orifice";
      parameter Modelica.SIunits.Diameter D_t = 1.7 "If Throttle value type: Diameter of throat";
      parameter Modelica.SIunits.Diameter L_t = 5 "If Throttle value type: Diameter of throat";
    
      // Condition for steady state
      parameter Boolean SteadyState = data.Steady "If true - starts from Steady State" annotation (
        Dialog(group = "Initialization"));
      // steady state values for flow rate and water level in surge tank
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = 0 "Initial flow rate in the surge tank" annotation (
        Dialog(group = "Initialization"));
      parameter Modelica.SIunits.Height h_0 = 69.9 "Initial water height in the surge tank";
      parameter Modelica.SIunits.Pressure p_ac = 4*data.p_a "Initial pressure of air-cushion inside the surge tank";
      parameter Modelica.SIunits.Temperature T_ac(displayUnit="degC") = 298.15 "Initial air-cushion temperature";
      Modelica.SIunits.Mass m "Water mass";
      Modelica.SIunits.Mass m_a = p_ac*A*(L-h_0/cos_theta)*data.M_a/(Modelica.Constants.R*T_ac) "Air mass inside surge tank";
      Modelica.SIunits.Momentum M "Water momuntum";
      Modelica.SIunits.Force Mdot "Difference in influent and effulent momentum";
      Modelica.SIunits.Force F "Total force acting in the surge tank";
      Modelica.SIunits.Area A = (pi*D ^ 2) / 4 "Cross sectional area of the surge tank";
      Modelica.SIunits.Area A_t = (pi*D_t ^ 2) / 4 "Cross sectional area of the throttle valve surge tank";
      Modelica.SIunits.Length l = h / cos_theta "Length of water in the surge tank";
      Real cos_theta = H / L "Slope ratio";
      Modelica.SIunits.Velocity v "Water velocity";
      Modelica.SIunits.Force F_p "Pressure force";
      Modelica.SIunits.Force F_f "Friction force";
      Modelica.SIunits.Force F_g "Gravity force";
      Modelica.SIunits.Pressure p_t "Pressure at top of the surge tank";
      Modelica.SIunits.Pressure p_b "Pressure at bottom of the surge tank";
      Real phiSO "Dimensionless factor based on the type of fitting ";
      // initial values for differential variables
      Modelica.SIunits.Height h(start = h_0) "Water height in the surge tank";
      Modelica.SIunits.VolumeFlowRate Vdot(start = Vdot_0) "Water flow rate";
    initial equation
      if SteadyState then
        der(M) = 0;
        der(m) = 0;
      else
        h = h_0;
      end if;
    equation
      der(m) = mdot "Mass balance";
      der(M) = Mdot+F "Momentum balance";
    
      if SurgeTankType == OpenHPL.Types.SurgeTank.STSimple then
        v = Vdot / A;
        m = data.rho * A * l;
        M = m * v;
        p_t = data.p_a;
        F_f = Functions.DarcyFriction.Friction(v, D, l, data.rho, data.mu, p_eps) + A * phiSO * 0.5 * data.rho * abs(v) * v;
        phiSO = 0;
        F_p = (p_b - p_t) * A;
      elseif SurgeTankType == OpenHPL.Types.SurgeTank.STAirCushion then
        v = Vdot / A;
        m = data.rho * A * l + m_a;
        M = m * v;
        p_t = p_ac * ((L - h_0 / cos_theta) / (L - l)) ^ data.gamma_air;
        F_f = Functions.DarcyFriction.Friction(v, D, l, data.rho, data.mu, p_eps) + A * phiSO * 0.5 * data.rho * abs(v) * v;
        phiSO = 0;
        F_p = (p_b - p_t) * A;
      elseif SurgeTankType == OpenHPL.Types.SurgeTank.STSharpOrifice then
        v = Vdot / A;
        m = data.rho * A * l;
        M = m * v;
        p_t = data.p_a;
        F_f = Functions.DarcyFriction.Friction(v, D, l, data.rho, data.mu, p_eps) + A * phiSO * 0.5 * data.rho * abs(v) * v;
        F_p = (p_b - p_t) * A;
        if v >= 0 then
          phiSO = Functions.Fitting.FittingPhi(v, D, D_so, L, 90, data.rho, data.mu, data.p_eps, OpenHPL.Types.Fitting.SharpOrifice);
        else
          phiSO = Functions.Fitting.FittingPhi(v, D_so, D, L, 90, data.rho, data.mu, data.p_eps, OpenHPL.Types.Fitting.SharpOrifice);
        end if;
      elseif SurgeTankType == OpenHPL.Types.SurgeTank.STThrottleValve then
        if l <= L_t then
          v = Vdot / A_t;
          m = data.rho * A_t * l;
          M = m * v;
          F_f = Functions.DarcyFriction.Friction(v, D_t, l, data.rho, data.mu, p_eps) + A_t * phiSO * 0.5 * data.rho * abs(v) * v;
          phiSO = 0;
          F_p = (p_b - p_t) * A;
        else
          v = Vdot * (1 / A_t + 1 / A) / 2;
          m = data.rho * (A_t * L_t + A * (l - L_t));
          M = data.rho * (A_t * L_t*Vdot/A_t + A * (l - L_t)*Vdot/A);
          if v > 0 then
            F_f = Functions.DarcyFriction.Friction(Vdot/A_t, D_t, L_t, data.rho, data.mu, p_eps) + Functions.DarcyFriction.Friction(Vdot/A, D, l - L_t, data.rho, data.mu, p_eps) + A_t * phiSO * 0.5 * data.rho * abs(Vdot/A_t) * Vdot/A_t;
            phiSO = Functions.Fitting.FittingPhi(Vdot/A_t, D_t, D, L, 90, data.rho, data.mu, data.p_eps, OpenHPL.Types.Fitting.Square);
          elseif v < 0 then
            F_f = Functions.DarcyFriction.Friction(Vdot/A_t, D_t, L_t, data.rho, data.mu, p_eps) + Functions.DarcyFriction.Friction(Vdot/A, D, l - L_t, data.rho, data.mu, p_eps) + A * phiSO * 0.5 * data.rho * abs(Vdot/A) * Vdot/A;
            phiSO = Functions.Fitting.FittingPhi(Vdot/A, D, D_t, L, 90, data.rho, data.mu, data.p_eps, OpenHPL.Types.Fitting.Square);
          else
            F_f = 0;
            phiSO = 0;
          end if;
          F_p = (p_b - (p_t+data.rho*data.g*(l-L_t))) * A_t+(p_t+data.rho*data.g*(l-L_t)-p_t)*A;
        end if;
        p_t = data.p_a;
      end if;
      mdot = data.rho * Vdot;
      Mdot = mdot * v;
      F = F_p - F_f - F_g;
      p_b = p_n "Linking bottom node pressure to connector";
      F_g = m * data.g * cos_theta;
      
    end SurgeChamber;
  
    model DraftTube "Model of a draft tube for reaction turbines"
      outer Presets data "Using standard data set";
      import Modelica.Constants.pi;
      parameter Types.DraftTube DraftTubeType = OpenHPL.Types.DraftTube.ConicalDiffuser "Types of draft tube" annotation (
        Dialog(group = "Draft tube types"));
    
      // geometrical parameters of the draft tube
      parameter Modelica.SIunits.Length H = 7 "Vertical height of conical diffuser" annotation (
        Dialog(group = "Geometry",enable=DraftTubeType == OpenHPL.Types.DraftTube.ConicalDiffuser));
      parameter Modelica.SIunits.Length L = 7.017 "Slant height of conical diffuser, for conical diffuser L=H/cos(diffusion_angle/2), diffusion_anlge=8" annotation (
        Dialog(group = "Geometry",enable=DraftTubeType == OpenHPL.Types.DraftTube.ConicalDiffuser));
      parameter Modelica.SIunits.Diameter D_i = 4 "Diameter of the inlet side" annotation (
        Dialog(group = "Geometry"));
      parameter Modelica.SIunits.Diameter D_o = 4.978 "Diameter of the outlet side, for conical diffuser D_o=D_i+2*H*tan(diffusion_angle/2)" annotation (
        Dialog(group = "Geometry"));
    
      parameter Modelica.SIunits.Length L_m = 4 "Length of Main section of Moody spreading pipe" annotation (
        Dialog(group = "Geometry",enable=DraftTubeType == OpenHPL.Types.DraftTube.MoodySpreadingPipe));
      parameter Modelica.SIunits.Length L_b = 3 "Length of Branch section of Moody spreading pipe" annotation (
        Dialog(group = "Geometry",enable=DraftTubeType == OpenHPL.Types.DraftTube.MoodySpreadingPipe));
    
      parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg theta = 5 "Angle at which conical diffuser is inclined" annotation (
        Dialog(group = "Geometry",enable=DraftTubeType == OpenHPL.Types.DraftTube.ConicalDiffuser));
      parameter Modelica.SIunits.Conversions.NonSIunits.Angle_deg theta_moody = 30 "Angle at which Moody spreading pipes are branched possible value is 15,30,45,60 or 90)" annotation (
        Dialog(group = "Geometry",enable=DraftTubeType == OpenHPL.Types.DraftTube.MoodySpreadingPipe));
      parameter Modelica.SIunits.Height p_eps = data.p_eps "Pipe roughness height" annotation (
        Dialog(group = "Geometry"));
      // condition of steady state
      parameter Boolean SteadyState = data.Steady "if true - starts from Steady State" annotation (
        Dialog(group = "Initialization"));
      // staedy state value for flow rate
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = data.V_0 "Initial flow rate in the pipe" annotation (
        Dialog(group = "Initialization"));
      // possible parameters for temperature variation. Not finished...
      // parameter Boolean TempUse = data.TempUse "If checked - the water temperature is not constant" annotation (Dialog(group = "Initialization"));
      // parameter Modelica.SIunits.Temperature T_0 = data.T_0 "Initial water temperature in the pipe" annotation (Dialog(group = "Initialization", enable = TempUse));
      // variables
      Modelica.SIunits.Diameter D_ = 0.5 * (D_i + D_o) "Average diameter";
      Modelica.SIunits.Area A_i = D_i ^ 2 * pi / 4 "Inlet cross-section area of draft tube";
      Modelica.SIunits.Area A_o = D_o ^ 2 * pi / 4 "Outlet cross-section area of draft tube";
      Modelica.SIunits.Area A_ = D_ ^ 2 * pi / 4 "Average cross-section area of conical diffuser";
    
      Modelica.SIunits.Mass m "Mass of water inside conical diffuser";
      Modelica.SIunits.Mass m_m "Mass of water inside Main section Moody spreading pipes";
      Modelica.SIunits.Mass m_b "Mass of water inside Branch section Moody spreading pipes";
    
      Modelica.SIunits.MassFlowRate mdot_m "Mass flow rate inside Main section of Moody spreading pipes";
      Modelica.SIunits.MassFlowRate mdot_b "Mass flow rate inside Branch section of Moody spreading pipes";
    
      Modelica.SIunits.Volume V "Volume of water inside the draft tube";
      Modelica.SIunits.Momentum M "Momentum of water inside the draft tube";
      Modelica.SIunits.Force Mdot "Rate of change of water momentum";
      Modelica.SIunits.Force F "Total force acting in the tube";
      Modelica.SIunits.Force F_p "Pressure force";
      Modelica.SIunits.Force F_f "Fluid frictional force";
      Modelica.SIunits.Force F_g "Weight of water";
      Modelica.SIunits.Force F_fm "Fluid frictional force in the Main section of Moody spreading pipe";
      Modelica.SIunits.Force F_fb "Fluid frictional force in the Branch section of Moody spreading pipe";
    
      //Real cos_theta = H / L "slope ratio";
      Modelica.SIunits.Velocity v "Water velocity for conical diffuser";
      Modelica.SIunits.Velocity v_m "Water velocity inside Main section of Moody spreading pipes";
      Modelica.SIunits.Velocity v_b "Water velocity inside Branch section of Moody spreading pipes";
      Modelica.SIunits.Pressure p_i "Inlet pressure";
      Modelica.SIunits.Pressure p_o "Outlet pressure";
      //Modelica.SIunits.Pressure dp = p_o-p_i "Pressure drop in and out of draft tube";
      Real phi_d "Generalized friction factor for draft tube";
      Real phi_d_o "Initial generalized friction factor for Moody spreading pipes";
    
      Modelica.SIunits.VolumeFlowRate Vdot(start = Vdot_0, fixed = true) "Volumeteric flow rate";
      Modelica.SIunits.VolumeFlowRate Vdot_b "Volumeteric flow rate for Branch section of Moody spreading pipes";
    
      Real cos_theta = Modelica.Math.cos(Modelica.SIunits.Conversions.from_deg(theta))
                                                                                      "Calculating cos_theta";
      Real cos_theta_moody = Modelica.Math.cos(Modelica.SIunits.Conversions.from_deg(theta_moody))
                                                                                                  "Calculating cos_theta_moody";
    
    
      Real cos_theta_moody_by_2 = Modelica.Math.cos(Modelica.SIunits.Conversions.from_deg(theta_moody/2))
                                                                                                  "Calculating cos_theta_moody_by_2";
    
     // connectors
      extends OpenHPL.Interfaces.ContactPort;
    initial equation
      if SteadyState then
        der(M) = 0;
        //der(n.T) = 0;
      else
        Vdot = Vdot_0;
        //n.T = p.T;
      end if;
    equation
      der(M) = Mdot + F "Momentum balance";
      if DraftTubeType == OpenHPL.Types.DraftTube.ConicalDiffuser then
        M = m*v;
        m = data.rho*V "Mass of water inside the draft tube";
        m_m=0;m_b=0; // Unimportant for conical diffuser
        V = pi*H/12*(D_i^2+D_o^2+D_i*D_o) "Volume of water inside the draft tube";
        v = Vdot/A_;
        Vdot_b = 0; // Unimportant for conical diffuser
        v_m=0;v_b=0; // Unimportant for conical diffuser
    
        Mdot = mdot*v;
        mdot = data.rho*Vdot;
        mdot_m=0; mdot_b=0; // Unimportant for conical diffuser
    
        F = F_p-F_g-F_f;
        F_p = p_i * A_i - p_o * A_o;
        F_f = Functions.DarcyFriction.Friction(v, D_, L, data.rho, data.mu, p_eps)+1/2*data.rho*v*abs(v)*A_i*phi_d;
        F_fm=0;F_fb=0;
        phi_d = 0.23*(1-D_i/D_o)^2;
        phi_d_o=0; // Unimportant for conical diffuser
        F_g = m*data.g*cos_theta;
    
      elseif DraftTubeType == OpenHPL.Types.DraftTube.MoodySpreadingPipe then
        // Taking momentum balance only on y-direction
        M = m_m*v_m+2*m_b*v_b*cos_theta_moody_by_2;
        m_m=data.rho*A_i*L_m; m_b=data.rho*A_o*L_m;
        m = m_m+2*m_b;
        v_m = Vdot/A_i; v_b=A_i/(2*A_o)*v_m; v=v_m;
        V = A_i*L_m+2*A_o*L_b;
    
        Mdot = mdot_m*v_m+2*mdot_b*cos_theta_moody_by_2;
        mdot_m=data.rho*Vdot; mdot_b=data.rho*Vdot_b; Vdot_b=A_o*v_b;
        mdot = mdot_m;
    
        F = F_p-F_g-F_f;
        F_p = p_i*A_i-2*p_o*A_o*cos_theta_moody_by_2;
        F_g = m_m*data.g+2*m_b*data.g*cos_theta_moody_by_2;
        F_f = F_fm+2*F_fb*cos_theta_moody_by_2+data.rho*v_m*abs(v_m)*A_i*phi_d;
        F_fm = Functions.DarcyFriction.Friction(v_m, D_i, L_m, data.rho, data.mu, p_eps);
        F_fb = Functions.DarcyFriction.Friction(v_b, D_o, L_b, data.rho, data.mu, p_eps);
    
        // calculating phi_d
        phi_d = 1+(v_b/v_m)^2-2*v_b/v_m*cos_theta_moody-phi_d_o*(v_b/v_m)^2;
        // phi_d_o is calculated based on theta_moody
        if theta_moody == 15 then
          phi_d_o = 0.04;
        elseif theta_moody == 30 then
          phi_d_o = 0.16;
        elseif theta_moody == 45 then
          phi_d_o = 0.36;
        elseif theta_moody == 60 then
          phi_d_o = 0.64;
        elseif theta_moody == 90 then
          phi_d_o = 1;
        end if;
    
      end if;
      
      // Connector
        p_i = i.p;
        p_o = o.p;
  
    end DraftTube;

    model Pipeline
      outer Presets data "Using standard data set";
      import Modelica.Constants.pi;
      
      // Geometrical parameters of the pipe
      parameter Modelica.SIunits.Length H = 25 "Height difference from the inlet to the outlet";
      parameter Modelica.SIunits.Length L = 6600 "Length of the pipe";
      parameter Modelica.SIunits.Diameter D_i = 5.8 "Diameter of the inlet side";
      parameter Modelica.SIunits.Diameter D_o = D_i "Diameter of the outlet side";
      parameter Modelica.SIunits.Height p_eps = data.p_eps "Pipe roughness height";
      
      // Condition of steady state
      parameter Boolean SteadyState = data.Steady "if true - starts from Steady State";
      
      // Steady state value for flow rate
      parameter Modelica.SIunits.VolumeFlowRate Vdot_0 = data.V_0 "Initial flow rate in the pipe";
      
      // Variables
      Modelica.SIunits.Diameter D_ = 0.5 * (D_i + D_o) "Average diameter";
      Modelica.SIunits.Mass m "water mass";
      Modelica.SIunits.Area A_i = D_i ^ 2 * pi / 4 "Inlet cross section area";
      Modelica.SIunits.Area A_o = D_o ^ 2 * pi / 4 "Outlet cross section area";
      Modelica.SIunits.Area A_ = D_ ^ 2 * pi / 4 "Average cross section area";
      Real cos_theta = H / L "slope ratio";
      Modelica.SIunits.Velocity v "Water velocity";
      Modelica.SIunits.Force F_f "Friction force";
      Modelica.SIunits.Momentum M "Water momentum";
      Modelica.SIunits.Pressure p_i "Inlet pressure";
      Modelica.SIunits.Pressure p_o "Outlet pressure";
      Modelica.SIunits.Pressure dp=p_o-p_i "Pressure difference across the pipe";
      Modelica.SIunits.VolumeFlowRate Vdot(start = Vdot_0) "Flow rate";
    
      // Connector
      extends OpenHPL.Interfaces.ContactPort;
    initial equation
      
      if SteadyState then
        der(M) = 0;
      end if;
      
    equation
      
      // Water volumetric flow rate through the pipe
      Vdot = mdot / data.rho;
      
      // Water velocity
      v = Vdot / A_;
      
      // Momentum and mass of water
      M = data.rho * L * Vdot;
      m = data.rho * A_ * L;
      
      // Friction force
      F_f = Functions.DarcyFriction.Friction(v, D_, L, data.rho, data.mu, p_eps);
      
      // Momentum balance
      der(M) = data.rho * Vdot ^ 2 * (1 / A_i - 1 / A_o) + p_i * A_i - p_o * A_o - F_f + m * data.g * cos_theta;
      
      // Pipe pressure
      p_i = i.p;
      p_o = o.p;

    end Pipeline;
  
  end Watercourse;

  package ElectricalInstallations

package HydraulicTurbines
      extends Modelica.Icons.GearIcon;

      model GeneralTurbine "Simple turbine model with mechanical connectors"
        outer Presets data "Using standard class with global parameters";
      
        parameter Boolean ValveCapacity =  true "If checked the guide vane capacity C_v should be specified, otherwise specify the nominal turbine parameters (net head and flow rate)";
        
        parameter Real C_v = 3.7 "Guide vane 'valve capacity'";
        
        parameter SI.Height H_n = 460 "Nominal net head";
        
        parameter SI.VolumeFlowRate Vdot_n = 23.4 "Nominal flow rate";
        
        parameter SI.PerUnit u_n = 0.95 "Nominal guide vane opening";
        
        parameter Boolean ConstEfficiency = true "If checked the constant efficiency eta_h is used,
          otherwise specify lookup table for efficiency";
        
        parameter SI.Efficiency eta_h = 0.9 "Turbine hydraulic efficiency";
        
        parameter Real lookup_table[:, :] = [0, 0.4; 0.2, 0.7; 0.5, 0.9; 0.95, 0.95; 1.0, 0.93] "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency.";
        
        parameter Boolean WaterCompress = false "If checked the water is compressible in the penstock";
      
        //extends BaseClasses.Power2Torque(power(y=Wdot_s));
        
        //extends OpenHPL.Interfaces.TurbineContacts2;
      
        SI.Pressure dp "Turbine pressure drop";
        SI.EnergyFlowRate Kdot_i_tr "Kinetic energy flow";
        SI.VolumeFlowRate Vdot "Flow rate";
        Real C_v_ "Guide vane 'valve capacity'";
      
        output SI.EnergyFlowRate Wdot_s "Shaft power";
        Modelica.Blocks.Tables.CombiTable1D look_up_table(table = lookup_table);
        Modelica.Blocks.Math.Feedback lossCorrection;
        
      equation
        
        Vdot = if WaterCompress then mdot / (data.rho * (1 + data.beta * (i.p - data.p_a))) else mdot / data.rho "Checking for water compressibility";
        
        look_up_table.u[1] = u_t "Link the guide vane opening";
        
        C_v_ = if ValveCapacity then C_v else Vdot_n/sqrt(H_n*data.g*data.rho/data.p_a)/u_n "Define guide vane 'valve capacity' base on the Nominal turbine parameters";
        
        dp = Vdot ^ 2 * data.p_a / (C_v_ * u_t) ^ 2 "turbine valve equation for pressure drop";
        
        dp = i.p - o.p "Link the pressure drop to the ports";
        
        Kdot_i_tr = dp * Vdot "Turbine energy balance";
        
        if ConstEfficiency then
          Wdot_s = eta_h * Kdot_i_tr;
        else
          Wdot_s = look_up_table.y[1] * Kdot_i_tr;
        end if;
      
      
        connect(P_out, lossCorrection.y);
        connect(lossCorrection.u1, power.y);
        connect(frictionLoss.power, lossCorrection.u2);

      end GeneralTurbine;

end HydraulicTurbines;

    package PowerHouse 
package Generators
      end Generators;

      package Controllers
      end Controllers;
    end PowerHouse;
  
  end ElectricalInstallations;

  package WorkingModels
    extends Modelica.Icons.ExamplesPackage;
  
    model BasicExample "Basic model of a Hydropower plant."
      extends Modelica.Icons.Example;
      
      HydroPowerPlant.WaterSources.Reservoir Reservoir(H_0 = 48);
      
      Modelica.Blocks.Sources.Ramp Control(duration = 1, height = -0.04615, offset = 0.7493, startTime = 600);
      
      HydroPowerPlant.WaterSources.Pipeline IntakeStructure(H = 23);
      
      HydroPowerPlant.WaterSources.Pipeline Discharge(H = 0.5, L = 600);
      
      HydroPowerPlant.WaterSources.Reservoir Tailrace(H_0 = 5);
      
      HydroPowerPlant.WaterSources.Pipeline Penstock(
        D_i = 3,
        D_o = 3,
        H = 428.5,
        L = 600,
        vertical = true);
      
      HydroPowerPlant.WaterSources.SurgeChamber SurgeChamber(h_0 = 69.9);
      
      HydroPowerPlant.ElectricalInstallations.HydraulicTurbines.GeneralTurbine Turbine(C_v = 3.7, ConstEfficiency = false, enable_nomSpeed = true);
      
      inner HydroPowerPlant.Presets data;
    
    equation
    
      connect(Turbine.o, Discharge.i);
      
      connect(Control.y, Turbine.u_t);
      
      connect(Penstock.o, Turbine.i);
      
      connect(Reservoir.o, IntakeStructure.i);
      
      connect(IntakeStructure.o, SurgeChamber.i);
      
      connect(SurgeChamber.o, Penstock.i);
      
      connect(Discharge.o, Tailrace.o);
    
    end BasicExample;
  end WorkingModels;
  annotation(
    version="0.9.0",
    versionDate="17/04/2022",
    uses(Modelica(version = "3.2.3")),
    preferredView="info",
    Documentation(info="<html>
      <p>HydroPowerPlant is a software package available for using in the OpenModelica Connection Editor development environment and used to simulate various mechanical and electrical systems and assemblies of hydroelectric power plants.</p>
      <p>The original <a href=\"https://github.com/CourteousSleet/Diploma\">repository</a>.</p>
</html>"));
    
end HydroPowerPlant;
